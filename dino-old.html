<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>T-Rex Runner</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #f7f7f7;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
        }
        
        body.inverted {
            background: #000;
        }
        
        .container {
            position: relative;
        }
        
        .icon {
            width: 44px;
            height: 47px;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 44 47"><path fill="%23535353" d="M22 0h22v47H0V25h22V0z"/></svg>');
            margin: 20px auto;
        }
        
        .icon-disabled {
            display: none;
        }
        
        #offline-resources {
            display: none;
        }
        
        .runner-container {
            height: 150px;
            max-width: 600px;
            overflow: hidden;
            position: relative;
        }
        
        .runner-canvas {
            height: 150px;
            max-width: 600px;
            opacity: 1;
            overflow: hidden;
            position: absolute;
            top: 0;
            z-index: 2;
        }
        
        .interstitial-wrapper {
            box-sizing: border-box;
            line-height: 1.6em;
            margin: 0 auto;
            max-width: 600px;
            width: 100%;
        }
        
        @media (max-width: 700px) {
            .interstitial-wrapper {
                padding: 0 10px;
            }
        }
        
        @media (max-height: 350px) {
            .runner-canvas {
                height: 120px;
            }
            .runner-container {
                height: 120px;
            }
        }
    </style>
</head>
<body id="t" class="offline">
    <div id="gameContainer">
        <div id="ui">
            <div id="score">0</div>
        </div>
        <canvas id="canvas"></canvas>
        
        <div id="startScreen">
            <div id="title">ü¶ñ CYBER T-REX ü¶ñ</div>
            <div class="subtitle">Endless Neon Runner</div>
            <div class="instruction">
                ‚ñ∂ TAP / SPACE - JUMP<br>
                ‚ñº DOWN - DUCK<br>
                ‚ö† AVOID OBSTACLES<br>
                ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ<br>
                PRESS TO START
            </div>
        </div>
        
        <div id="gameOverScreen" class="hidden">
            <div id="title">‚ö† GAME OVER ‚ö†</div>
            <div id="finalScore">SCORE: 0</div>
            <div id="highScore">BEST: 0</div>
            <div class="instruction">
                ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ<br>
                PRESS TO RESTART
            </div>
        </div>
    </div>

    <script>
        const tg = window.Telegram?.WebApp;
        if (tg) {
            tg.ready();
            tg.expand();
        }

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('gameContainer');
        
        function resizeCanvas() {
            const maxWidth = Math.min(window.innerWidth, 800);
            const maxHeight = Math.min(window.innerHeight, 500);
            
            canvas.width = maxWidth;
            canvas.height = maxHeight;
            container.style.width = maxWidth + 'px';
            container.style.height = maxHeight + 'px';
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game constants
        const GRAVITY = 0.8;
        const JUMP_POWER = -15;
        const GROUND_Y = canvas.height - 80;
        const DINO_X = 80;
        const OBSTACLE_SPEED = 5;
        const SPAWN_INTERVAL = 90;
        
        // Game state
        let gameRunning = false;
        let score = 0;
        let highScore = parseInt(localStorage.getItem('cyberDinoHighScore') || '0');
        let frameCount = 0;
        let gameSpeed = OBSTACLE_SPEED;
        
        // Dino
        const dino = {
            x: DINO_X,
            y: GROUND_Y,
            width: 50,
            height: 50,
            velocityY: 0,
            jumping: false,
            ducking: false,
            legFrame: 0
        };
        
        // Obstacles
        let obstacles = [];
        let spawnTimer = SPAWN_INTERVAL;
        
        // Particles
        let particles = [];
        
        // Background
        let bgX = 0;
        
        function createParticle(x, y, color) {
            for (let i = 0; i < 3; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 1,
                    color: color,
                    size: Math.random() * 3 + 1
                });
            }
        }
        
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.02;
                p.vx *= 0.98;
                p.vy *= 0.98;
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }
        
        function drawParticles() {
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.shadowBlur = 15;
                ctx.shadowColor = p.color;
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, p.size, p.size);
            });
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
        }
        
        function drawBackground() {
            // Moving grid
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.2;
            
            // Vertical lines
            for (let x = bgX % 50; x < canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let y = 0; y < canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            ctx.globalAlpha = 1;
            
            // Ground line
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#00ff00';
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(0, GROUND_Y + dino.height);
            ctx.lineTo(canvas.width, GROUND_Y + dino.height);
            ctx.stroke();
            ctx.shadowBlur = 0;
        }
        
        function drawDino() {
            const dinoHeight = dino.ducking ? 30 : dino.height;
            const dinoWidth = dino.ducking ? 60 : dino.width;
            
            // Trail effect
            if (Math.random() < 0.3) {
                createParticle(dino.x, dino.y + dinoHeight / 2, '#ff00ff');
            }
            
            ctx.save();
            
            // Body glow
            ctx.shadowBlur = 25;
            ctx.shadowColor = '#ff00ff';
            
            // Main body
            ctx.fillStyle = '#ff00ff';
            ctx.fillRect(dino.x, dino.y, dinoWidth, dinoHeight);
            
            // Inner body
            ctx.fillStyle = '#800080';
            ctx.fillRect(dino.x + 5, dino.y + 5, dinoWidth - 10, dinoHeight - 10);
            
            if (!dino.ducking) {
                // Head
                ctx.fillStyle = '#ff00ff';
                ctx.fillRect(dino.x + dinoWidth, dino.y, 20, 25);
                
                // Eye glow
                ctx.shadowColor = '#00ffff';
                ctx.fillStyle = '#00ffff';
                ctx.fillRect(dino.x + dinoWidth + 5, dino.y + 8, 8, 8);
            }
            
            // Animated legs
            const legY = dino.y + dinoHeight;
            const legOffset = Math.floor(dino.legFrame / 5) % 2 === 0 ? 0 : 8;
            
            ctx.fillStyle = '#ff00ff';
            ctx.fillRect(dino.x + 10, legY, 10, 20 + legOffset);
            ctx.fillRect(dino.x + 30, legY, 10, 20 - legOffset);
            
            ctx.restore();
            ctx.shadowBlur = 0;
        }
        
        function drawObstacle(obs) {
            ctx.shadowBlur = 25;
            ctx.shadowColor = '#00ffff';
            
            if (obs.type === 'cactus') {
                // Main column
                ctx.fillStyle = '#00ffff';
                ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                
                // Inner
                ctx.fillStyle = '#008080';
                ctx.fillRect(obs.x + 4, obs.y + 4, obs.width - 8, obs.height - 8);
                
                // Arms
                if (obs.arms) {
                    ctx.fillStyle = '#00ffff';
                    ctx.fillRect(obs.x - 10, obs.y + 20, 10, 25);
                    ctx.fillRect(obs.x + obs.width, obs.y + 20, 10, 25);
                }
                
                // Sparks
                if (Math.random() < 0.1) {
                    createParticle(obs.x + obs.width / 2, obs.y, '#00ffff');
                }
            } else {
                // Flying obstacle (pterodactyl)
                const wingY = Math.sin(frameCount * 0.2) * 5;
                
                ctx.shadowColor = '#ffff00';
                ctx.fillStyle = '#ffff00';
                
                // Body
                ctx.fillRect(obs.x + 15, obs.y + 15, 30, 20);
                
                // Head
                ctx.fillRect(obs.x + 45, obs.y + 12, 20, 15);
                
                // Wings
                ctx.fillRect(obs.x, obs.y + wingY, 15, 25);
                ctx.fillRect(obs.x + 45, obs.y + wingY, 15, 25);
                
                // Beak
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(obs.x + 65, obs.y + 15, 10, 8);
                
                // Trail
                if (Math.random() < 0.2) {
                    createParticle(obs.x, obs.y + 20, '#ffff00');
                }
            }
            
            ctx.shadowBlur = 0;
        }
        
        function spawnObstacle() {
            const type = Math.random() > 0.3 ? 'cactus' : 'bird';
            
            if (type === 'cactus') {
                obstacles.push({
                    type: 'cactus',
                    x: canvas.width,
                    y: GROUND_Y - 40,
                    width: 25 + Math.random() * 20,
                    height: 40 + Math.random() * 30,
                    arms: Math.random() > 0.5
                });
            } else {
                const heights = [GROUND_Y - 80, GROUND_Y - 120, GROUND_Y - 160];
                obstacles.push({
                    type: 'bird',
                    x: canvas.width,
                    y: heights[Math.floor(Math.random() * heights.length)],
                    width: 70,
                    height: 40
                });
            }
        }
        
        function updateDino() {
            if (gameRunning) {
                // Gravity
                if (dino.y < GROUND_Y || dino.velocityY < 0) {
                    dino.velocityY += GRAVITY;
                    dino.y += dino.velocityY;
                }
                
                // Ground collision
                if (dino.y >= GROUND_Y) {
                    dino.y = GROUND_Y;
                    dino.velocityY = 0;
                    dino.jumping = false;
                }
                
                // Leg animation
                if (!dino.jumping) {
                    dino.legFrame += gameSpeed;
                }
            }
        }
        
        function updateObstacles() {
            if (gameRunning) {
                // Spawn
                if (spawnTimer <= 0) {
                    spawnObstacle();
                    spawnTimer = SPAWN_INTERVAL + Math.random() * 40;
                } else {
                    spawnTimer--;
                }
                
                // Move and check collision
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    const obs = obstacles[i];
                    obs.x -= gameSpeed;
                    
                    // Check collision
                    const dinoBox = {
                        x: dino.x + 5,
                        y: dino.y + 5,
                        width: (dino.ducking ? 60 : dino.width) - 10,
                        height: (dino.ducking ? 30 : dino.height) - 10
                    };
                    
                    const obsBox = {
                        x: obs.x + 5,
                        y: obs.y + 5,
                        width: obs.width - 10,
                        height: obs.height - 10
                    };
                    
                    if (dinoBox.x < obsBox.x + obsBox.width &&
                        dinoBox.x + dinoBox.width > obsBox.x &&
                        dinoBox.y < obsBox.y + obsBox.height &&
                        dinoBox.y + dinoBox.height > obsBox.y) {
                        gameOver();
                    }
                    
                    // Remove off-screen
                    if (obs.x + obs.width < 0) {
                        obstacles.splice(i, 1);
                        score++;
                        document.getElementById('score').textContent = score;
                        if (tg) tg.HapticFeedback?.impactOccurred('light');
                    }
                }
                
                // Increase speed gradually
                gameSpeed = Math.min(OBSTACLE_SPEED + score * 0.02, 12);
            }
        }
        
        function jump() {
            if (!dino.jumping && dino.y === GROUND_Y) {
                dino.velocityY = JUMP_POWER;
                dino.jumping = true;
                if (tg) tg.HapticFeedback?.impactOccurred('light');
                createParticle(dino.x + dino.width / 2, dino.y + dino.height, '#ff00ff');
            }
        }
        
        function duck(isDucking) {
            if (!dino.jumping) {
                dino.ducking = isDucking;
            }
        }
        
        function gameOver() {
            gameRunning = false;
            
            // Explosion
            for (let i = 0; i < 30; i++) {
                createParticle(
                    dino.x + dino.width / 2, 
                    dino.y + dino.height / 2,
                    i % 3 === 0 ? '#ff00ff' : i % 3 === 1 ? '#00ffff' : '#ffff00'
                );
            }
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('cyberDinoHighScore', highScore.toString());
                if (tg) tg.HapticFeedback?.notificationOccurred('success');
            } else {
                if (tg) tg.HapticFeedback?.notificationOccurred('error');
            }
            
            document.getElementById('finalScore').textContent = 'SCORE: ' + score;
            document.getElementById('highScore').textContent = 'BEST: ' + highScore;
            document.getElementById('gameOverScreen').classList.remove('hidden');
        }
        
        function startGame() {
            gameRunning = true;
            score = 0;
            frameCount = 0;
            gameSpeed = OBSTACLE_SPEED;
            obstacles = [];
            spawnTimer = SPAWN_INTERVAL;
            
            dino.y = GROUND_Y;
            dino.velocityY = 0;
            dino.jumping = false;
            dino.ducking = false;
            dino.legFrame = 0;
            
            document.getElementById('score').textContent = '0';
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            
            if (tg) tg.HapticFeedback?.impactOccurred('medium');
        }
        
        function gameLoop() {
            // Background gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#0a0014');
            gradient.addColorStop(0.5, '#1a0a2e');
            gradient.addColorStop(1, '#0a0014');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Scanlines
            for (let y = 0; y < canvas.height; y += 4) {
                ctx.globalAlpha = 0.05;
                ctx.fillStyle = '#000';
                ctx.fillRect(0, y, canvas.width, 2);
            }
            ctx.globalAlpha = 1;
            
            // Update background
            if (gameRunning) {
                bgX -= gameSpeed * 0.5;
            }
            
            drawBackground();
            
            if (gameRunning) {
                updateDino();
                updateObstacles();
                updateParticles();
                frameCount++;
            }
            
            obstacles.forEach(drawObstacle);
            drawParticles();
            drawDino();
            
            requestAnimationFrame(gameLoop);
        }
        
        // Controls
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                e.preventDefault();
                if (!gameRunning) {
                    startGame();
                } else {
                    jump();
                }
            }
            if (e.code === 'ArrowDown') {
                e.preventDefault();
                duck(true);
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.code === 'ArrowDown') {
                e.preventDefault();
                duck(false);
            }
        });
        
        canvas.addEventListener('click', () => {
            if (!gameRunning) {
                startGame();
            } else {
                jump();
            }
        });
        
        let touchStartY = 0;
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchStartY = e.touches[0].clientY;
            if (!gameRunning) {
                startGame();
            } else {
                jump();
            }
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touchY = e.touches[0].clientY;
            if (touchY > touchStartY + 30) {
                duck(true);
            }
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            duck(false);
        });
        
        gameLoop();
    </script>
</body>
</html>
