<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>T-Rex Runner</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            touch-action: none;
        }
        
        #gameContainer {
            position: relative;
            background: #f7f7f7;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }
        
        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
            z-index: 10;
        }
        
        #score, #highScore {
            font-size: 20px;
            font-weight: bold;
            color: #535353;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }
        
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(247, 247, 247, 0.95);
            z-index: 5;
        }
        
        #startScreen.hidden {
            display: none;
        }
        
        #startText {
            font-size: 24px;
            color: #535353;
            margin-bottom: 20px;
            animation: pulse 2s ease-in-out infinite;
        }
        
        #controls {
            font-size: 14px;
            color: #888;
            text-align: center;
            line-height: 1.6;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        @media (max-width: 600px) {
            #gameContainer {
                border-radius: 0;
                width: 100vw !important;
                height: 100vh !important;
            }
            
            #score, #highScore {
                font-size: 16px;
            }
            
            #ui {
                top: 10px;
                left: 10px;
                right: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="ui">
            <div id="score">00000</div>
            <div id="highScore">HI 00000</div>
        </div>
        <canvas id="canvas"></canvas>
        <div id="startScreen">
            <div id="startText">ü¶ñ –ù–ê–ñ–ú–ò –ü–†–û–ë–ï–õ ü¶ñ</div>
            <div id="controls">
                üñ±Ô∏è –ü–†–û–ë–ï–õ –∏–ª–∏ –¢–ê–ü - –ø—Ä—ã–∂–æ–∫<br>
                ‚¨áÔ∏è –í–ù–ò–ó - –ø—Ä–∏—Å–µ—Å—Ç—å<br>
                üéØ –ò–∑–±–µ–≥–∞–π –∫–∞–∫—Ç—É—Å—ã –∏ –ø—Ç–µ—Ä–æ–¥–∞–∫—Ç–∏–ª–∏
            </div>
        </div>
    </div>

    <script>
        // Telegram WebApp
        const tg = window.Telegram?.WebApp;
        if (tg) {
            tg.ready();
            tg.expand();
        }

        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('gameContainer');
        
        // Responsive canvas
        function resizeCanvas() {
            const maxWidth = Math.min(window.innerWidth, 800);
            const maxHeight = Math.min(window.innerHeight, 400);
            
            canvas.width = maxWidth;
            canvas.height = maxHeight;
            container.style.width = maxWidth + 'px';
            container.style.height = maxHeight + 'px';
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game constants
        const GRAVITY = 0.6;
        const JUMP_POWER = -12;
        const DUCK_JUMP_POWER = -8;
        const GROUND_HEIGHT = canvas.height - 40;
        const INITIAL_SPEED = 6;
        const SPEED_INCREMENT = 0.0005;
        const MAX_SPEED = 13;
        
        // Game state
        let gameRunning = false;
        let gameSpeed = INITIAL_SPEED;
        let score = 0;
        let highScore = parseInt(localStorage.getItem('dinoHighScore') || '0');
        let frameCount = 0;
        
        // Dino
        const dino = {
            x: 50,
            y: GROUND_HEIGHT,
            width: 44,
            height: 47,
            velocityY: 0,
            jumping: false,
            ducking: false,
            animFrame: 0,
            animSpeed: 0
        };
        
        // Obstacles
        let obstacles = [];
        const OBSTACLE_SPAWN_DELAY = 100;
        let obstacleTimer = OBSTACLE_SPAWN_DELAY;
        
        // Clouds
        let clouds = [];
        
        // Update high score display
        document.getElementById('highScore').textContent = 'HI ' + String(highScore).padStart(5, '0');
        
        // Drawing functions
        function drawDino() {
            ctx.fillStyle = '#535353';
            
            const dinoHeight = dino.ducking ? 30 : dino.height;
            const dinoWidth = dino.ducking ? 55 : dino.width;
            
            // Body
            ctx.fillRect(dino.x, dino.y - dinoHeight + 47, dinoWidth, dinoHeight);
            
            // Head (only when not ducking)
            if (!dino.ducking) {
                ctx.fillRect(dino.x - 10, dino.y - dinoHeight - 10 + 47, 20, 20);
                
                // Eye
                ctx.fillStyle = '#fff';
                ctx.fillRect(dino.x - 5, dino.y - dinoHeight - 5 + 47, 5, 5);
            }
            
            // Legs animation
            const legOffset = Math.floor(dino.animFrame / 10) % 2 === 0 ? 0 : 5;
            ctx.fillStyle = '#535353';
            
            if (dino.ducking) {
                // Ducking legs
                ctx.fillRect(dino.x + 10, dino.y + 17, 8, 15 + legOffset);
                ctx.fillRect(dino.x + 30, dino.y + 17, 8, 15 - legOffset);
            } else {
                // Normal legs
                ctx.fillRect(dino.x + 10, dino.y + 27, 8, 20 + legOffset);
                ctx.fillRect(dino.x + 26, dino.y + 27, 8, 20 - legOffset);
            }
        }
        
        function drawObstacle(obs) {
            ctx.fillStyle = '#535353';
            
            if (obs.type === 'cactus') {
                // Cactus body
                ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                
                // Cactus arms
                if (obs.variant === 1) {
                    ctx.fillRect(obs.x - 8, obs.y + 15, 8, 15);
                    ctx.fillRect(obs.x + obs.width, obs.y + 15, 8, 15);
                }
            } else if (obs.type === 'bird') {
                // Pterodactyl wings
                const wingY = obs.y + Math.sin(frameCount * 0.3) * 3;
                
                // Body
                ctx.fillRect(obs.x + 10, obs.y + 10, 25, 15);
                
                // Head
                ctx.fillRect(obs.x + 35, obs.y + 8, 15, 10);
                
                // Wings
                ctx.fillRect(obs.x, wingY, 10, 20);
                ctx.fillRect(obs.x + 35, wingY, 10, 20);
                
                // Beak
                ctx.fillRect(obs.x + 50, obs.y + 10, 8, 5);
            }
        }
        
        function drawCloud(cloud) {
            ctx.fillStyle = '#ccc';
            
            // Cloud shape
            ctx.fillRect(cloud.x, cloud.y, 40, 12);
            ctx.fillRect(cloud.x + 10, cloud.y - 8, 25, 12);
            ctx.fillRect(cloud.x + 20, cloud.y - 14, 20, 12);
        }
        
        function drawGround() {
            ctx.strokeStyle = '#535353';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, GROUND_HEIGHT + 47);
            ctx.lineTo(canvas.width, GROUND_HEIGHT + 47);
            ctx.stroke();
            
            // Ground dashes
            const dashWidth = 10;
            const dashGap = 10;
            const dashOffset = (frameCount * gameSpeed) % (dashWidth + dashGap);
            
            for (let x = -dashOffset; x < canvas.width; x += dashWidth + dashGap) {
                ctx.fillRect(x, GROUND_HEIGHT + 49, dashWidth, 2);
            }
        }
        
        function drawScore() {
            document.getElementById('score').textContent = String(Math.floor(score)).padStart(5, '0');
        }
        
        // Game logic
        function spawnObstacle() {
            const type = Math.random() > 0.3 ? 'cactus' : 'bird';
            
            const obstacle = {
                x: canvas.width + 50,
                type: type
            };
            
            if (type === 'cactus') {
                obstacle.variant = Math.floor(Math.random() * 2);
                obstacle.width = 20 + Math.random() * 20;
                obstacle.height = 40 + Math.random() * 20;
                obstacle.y = GROUND_HEIGHT - obstacle.height + 47;
            } else {
                obstacle.width = 50;
                obstacle.height = 35;
                const heights = [GROUND_HEIGHT - 20, GROUND_HEIGHT - 50, GROUND_HEIGHT - 80];
                obstacle.y = heights[Math.floor(Math.random() * heights.length)];
            }
            
            obstacles.push(obstacle);
        }
        
        function spawnCloud() {
            clouds.push({
                x: canvas.width + 50,
                y: 30 + Math.random() * 80,
                speed: 0.5 + Math.random() * 1
            });
        }
        
        function updateDino() {
            // Gravity
            if (dino.y < GROUND_HEIGHT || dino.velocityY < 0) {
                dino.velocityY += GRAVITY;
                dino.y += dino.velocityY;
            }
            
            // Ground collision
            if (dino.y >= GROUND_HEIGHT) {
                dino.y = GROUND_HEIGHT;
                dino.velocityY = 0;
                dino.jumping = false;
            }
            
            // Animation
            if (!dino.jumping) {
                dino.animFrame += gameSpeed;
            }
        }
        
        function updateObstacles() {
            // Spawn new obstacles
            if (obstacleTimer <= 0) {
                spawnObstacle();
                obstacleTimer = OBSTACLE_SPAWN_DELAY + Math.random() * 50;
            } else {
                obstacleTimer--;
            }
            
            // Move and remove obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].x -= gameSpeed;
                
                if (obstacles[i].x + obstacles[i].width < 0) {
                    obstacles.splice(i, 1);
                }
            }
        }
        
        function updateClouds() {
            // Spawn clouds
            if (Math.random() < 0.01) {
                spawnCloud();
            }
            
            // Move clouds
            for (let i = clouds.length - 1; i >= 0; i--) {
                clouds[i].x -= clouds[i].speed;
                
                if (clouds[i].x < -50) {
                    clouds.splice(i, 1);
                }
            }
        }
        
        function checkCollision() {
            const dinoBox = {
                x: dino.x + 5,
                y: dino.y - (dino.ducking ? 30 : dino.height) + 47 + 5,
                width: (dino.ducking ? 55 : dino.width) - 10,
                height: (dino.ducking ? 30 : dino.height) - 10
            };
            
            for (const obs of obstacles) {
                const obsBox = {
                    x: obs.x + 5,
                    y: obs.y + 5,
                    width: obs.width - 10,
                    height: obs.height - 10
                };
                
                if (dinoBox.x < obsBox.x + obsBox.width &&
                    dinoBox.x + dinoBox.width > obsBox.x &&
                    dinoBox.y < obsBox.y + obsBox.height &&
                    dinoBox.y + dinoBox.height > obsBox.y) {
                    return true;
                }
            }
            
            return false;
        }
        
        function jump() {
            if (!dino.jumping && dino.y === GROUND_HEIGHT) {
                dino.velocityY = dino.ducking ? DUCK_JUMP_POWER : JUMP_POWER;
                dino.jumping = true;
                
                if (tg) tg.HapticFeedback?.impactOccurred('light');
            }
        }
        
        function duck(isDucking) {
            if (!dino.jumping) {
                dino.ducking = isDucking;
            }
        }
        
        function gameOver() {
            gameRunning = false;
            
            // Update high score
            if (score > highScore) {
                highScore = Math.floor(score);
                localStorage.setItem('dinoHighScore', highScore.toString());
                document.getElementById('highScore').textContent = 'HI ' + String(highScore).padStart(5, '0');
                
                if (tg) tg.HapticFeedback?.notificationOccurred('success');
            } else {
                if (tg) tg.HapticFeedback?.notificationOccurred('error');
            }
            
            // Show restart screen
            document.getElementById('startScreen').classList.remove('hidden');
            document.getElementById('startText').textContent = 'ü¶ñ GAME OVER! ü¶ñ';
            document.getElementById('controls').innerHTML = 
                'üìä –°—á—ë—Ç: ' + Math.floor(score) + '<br>' +
                'üèÜ –†–µ–∫–æ—Ä–¥: ' + highScore + '<br><br>' +
                '–ù–∞–∂–º–∏ –ü–†–û–ë–ï–õ –¥–ª—è —Ä–µ—Å—Ç–∞—Ä—Ç–∞';
        }
        
        function startGame() {
            gameRunning = true;
            gameSpeed = INITIAL_SPEED;
            score = 0;
            frameCount = 0;
            obstacles = [];
            clouds = [];
            obstacleTimer = OBSTACLE_SPAWN_DELAY;
            
            dino.y = GROUND_HEIGHT;
            dino.velocityY = 0;
            dino.jumping = false;
            dino.ducking = false;
            dino.animFrame = 0;
            
            document.getElementById('startScreen').classList.add('hidden');
            
            if (tg) tg.HapticFeedback?.impactOccurred('medium');
        }
        
        // Game loop
        function gameLoop() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (gameRunning) {
                // Update
                updateDino();
                updateObstacles();
                updateClouds();
                
                // Increase speed
                if (gameSpeed < MAX_SPEED) {
                    gameSpeed += SPEED_INCREMENT;
                }
                
                // Update score
                score += gameSpeed * 0.01;
                frameCount++;
                
                // Check collision
                if (checkCollision()) {
                    gameOver();
                }
            }
            
            // Draw
            drawGround();
            clouds.forEach(drawCloud);
            obstacles.forEach(drawObstacle);
            drawDino();
            drawScore();
            
            requestAnimationFrame(gameLoop);
        }
        
        // Controls
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                e.preventDefault();
                if (!gameRunning) {
                    startGame();
                } else {
                    jump();
                }
            }
            
            if (e.code === 'ArrowDown') {
                e.preventDefault();
                duck(true);
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.code === 'ArrowDown') {
                e.preventDefault();
                duck(false);
            }
        });
        
        // Touch controls
        let touchStartY = 0;
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchStartY = e.touches[0].clientY;
            
            if (!gameRunning) {
                startGame();
            } else {
                jump();
            }
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touchY = e.touches[0].clientY;
            
            if (touchY > touchStartY + 30) {
                duck(true);
            } else {
                duck(false);
            }
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            duck(false);
        });
        
        // Mouse controls
        canvas.addEventListener('click', (e) => {
            if (!gameRunning) {
                startGame();
            } else {
                jump();
            }
        });
        
        // Start game loop
        gameLoop();
    </script>
</body>
</html>
