<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>Cyber Runner</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #0a0e27;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }

        #game {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            display: block;
            image-rendering: pixelated;
        }

        .hud {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 15px 20px;
            background: linear-gradient(180deg, rgba(10,14,39,0.9) 0%, transparent 100%);
            z-index: 10;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .score-box {
            font-size: 28px;
            font-weight: bold;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88, 0 0 20px #00ff88;
            letter-spacing: 2px;
        }

        .best-box {
            font-size: 18px;
            color: #00ccff;
            text-shadow: 0 0 10px #00ccff;
        }

        .overlay {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(10, 14, 39, 0.95);
            z-index: 20;
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        .overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .menu {
            text-align: center;
            padding: 40px;
            background: linear-gradient(135deg, #1a1f3a 0%, #0f1428 100%);
            border: 2px solid #00ff88;
            border-radius: 20px;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.3), inset 0 0 20px rgba(0, 255, 136, 0.1);
            max-width: 90%;
        }

        .menu h1 {
            font-size: 48px;
            color: #00ff88;
            text-shadow: 0 0 20px #00ff88;
            margin-bottom: 10px;
            letter-spacing: 4px;
        }

        .menu p {
            font-size: 16px;
            color: #aaa;
            margin-bottom: 30px;
        }

        .btn {
            padding: 15px 40px;
            font-size: 20px;
            font-weight: bold;
            color: #0a0e27;
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.8);
        }

        .btn:active {
            transform: translateY(0);
        }

        .instructions {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 10;
            pointer-events: none;
            font-size: 16px;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body>
    <canvas id="game"></canvas>
    
    <div class="hud">
        <div class="score-box">
            <span id="score">0</span>
        </div>
        <div class="best-box">
            BEST: <span id="best">0</span>
        </div>
    </div>

    <div class="overlay" id="overlay">
        <div class="menu">
            <h1>CYBER RUNNER</h1>
            <p id="menuText">Беги, прыгай, скользи. Выживи как можно дольше!</p>
            <button class="btn" id="startBtn">СТАРТ</button>
        </div>
    </div>

    <div class="instructions" id="instructions">
        ТАП ДЛЯ ПРЫЖКА | ДОЛГИЙ ТАП ДЛЯ СЛАЙДА
    </div>

    <script>
        const tg = window.Telegram?.WebApp;
        try {
            tg?.ready();
            tg?.expand();
            tg?.enableClosingConfirmation();
            tg?.setHeaderColor('#0a0e27');
            tg?.setBackgroundColor('#0a0e27');
        } catch (err) {
            console.warn('Telegram WebApp API unavailable');
        }

        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const overlay = document.getElementById('overlay');
        const menuText = document.getElementById('menuText');
        const startBtn = document.getElementById('startBtn');
        const scoreEl = document.getElementById('score');
        const bestEl = document.getElementById('best');
        const instructions = document.getElementById('instructions');

        let W, H, groundY;
        let player, obstacles, particles, clouds;
        let score, bestScore, gameState, frame, speed, baseSpeed;
        let touchStartTime, isTouchHeld;

        function resize() {
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
            groundY = H * 0.75;
            init();
        }

        function init() {
            player = {
                x: W * 0.15,
                y: groundY,
                w: 40,
                h: 60,
                vy: 0,
                state: 'run',
                frame: 0,
                color: '#00ff88'
            };
            
            obstacles = [];
            particles = [];
            clouds = [];
            
            for (let i = 0; i < 5; i++) {
                clouds.push({
                    x: Math.random() * W,
                    y: Math.random() * H * 0.5,
                    w: 80 + Math.random() * 100,
                    h: 40 + Math.random() * 30,
                    speed: 0.5 + Math.random() * 1
                });
            }
            
            score = 0;
            bestScore = parseInt(localStorage.getItem('cyberRunnerBest') || '0');
            bestEl.textContent = bestScore;
            
            frame = 0;
            baseSpeed = 3;
            speed = baseSpeed;
            touchStartTime = 0;
            isTouchHeld = false;
        }

        function haptic(type) {
            try {
                tg?.HapticFeedback?.impactOccurred(type);
            } catch (_) {}
        }

        function addParticles(x, y, color, count = 10) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const velocity = 2 + Math.random() * 6;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * velocity,
                    vy: Math.sin(angle) * velocity - 2,  // Небольшой подъём
                    life: 1,
                    color,
                    size: 2 + Math.random() * 5,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.3
                });
            }
        }

        function jump() {
            if (player.state === 'run') {
                player.vy = -16;  // Оптимальная высота прыжка
                player.state = 'jump';
                haptic('light');
                addParticles(player.x, player.y + player.h, '#00ff88', 12);
                addParticles(player.x + player.w/2, player.y + player.h, '#00ffff', 8);
            }
        }

        function slide() {
            if (player.state === 'run') {
                player.state = 'slide';
                player.h = 30;
                haptic('light');
                // Эффект слайда
                addParticles(player.x - 10, player.y + player.h, '#00ff88', 5);
            }
        }

        function update() {
            if (gameState !== 'play') return;

            frame++;
            player.frame++;
            
            if (player.state === 'jump') {
                player.vy += 0.7;  // Сбалансированная гравитация
                player.y += player.vy;
                
                // Добавляем частицы при падении
                if (player.vy > 5 && frame % 3 === 0) {
                    addParticles(player.x + player.w/2, player.y + player.h, 'rgba(0, 255, 136, 0.3)', 2);
                }
                
                if (player.y >= groundY) {
                    player.y = groundY;
                    player.vy = 0;
                    player.state = 'run';
                    player.h = 60;
                    haptic('rigid');
                    // Эффект приземления
                    addParticles(player.x + player.w/2, player.y + player.h, '#00ff88', 15);
                }
            }
            
            if (player.state === 'slide') {
                if (player.frame % 20 === 0) {
                    player.state = 'run';
                    player.h = 60;
                }
                // Частицы скольжения
                if (frame % 4 === 0) {
                    addParticles(player.x - 5, player.y + player.h, '#00dd99', 3);
                }
            }

            // Плавное ускорение с балансом
            speed = baseSpeed + Math.min(score * 0.08, 8);  // Макс. прибавка 8

            // Умная генерация препятствий
            const spawnInterval = Math.max(60, 120 - score * 1.5);  // Частота появления
            if (frame % Math.floor(spawnInterval) === 0) {
                let type, obsY, obsH, obsW;
                
                // Разнообразие препятствий в зависимости от прогресса
                const random = Math.random();
                const lastObs = obstacles[obstacles.length - 1];
                
                // Избегаем повторов
                if (lastObs && random < 0.3) {
                    type = lastObs.type === 'low' ? 'high' : 'low';
                } else {
                    type = random > 0.55 ? 'high' : 'low';
                }
                
                if (type === 'low') {
                    // Шипы на земле - разная высота
                    obsH = 45 + Math.random() * 20;
                    obsY = groundY + player.h - obsH;
                    obsW = 25 + Math.floor(score / 10) * 2;  // Растут со счётом
                } else {
                    // Летающие дроны - разная высота
                    obsH = 25 + Math.random() * 10;
                    const heightVariation = [70, 85, 100, 115];
                    obsY = groundY - heightVariation[Math.floor(Math.random() * heightVariation.length)];
                    obsW = 35 + Math.random() * 10;
                }
                
                obstacles.push({
                    x: W + 10,
                    y: obsY,
                    w: obsW,
                    h: obsH,
                    type,
                    passed: false
                });
            }

            obstacles.forEach((obs, i) => {
                obs.x -= speed;
                
                if (!obs.passed && obs.x + obs.w < player.x) {
                    obs.passed = true;
                    score++;
                    scoreEl.textContent = score;
                    haptic('soft');
                    addParticles(obs.x + obs.w / 2, obs.y, '#00ccff', 15);
                    
                    if (score > bestScore) {
                        bestScore = score;
                        localStorage.setItem('cyberRunnerBest', bestScore);
                        bestEl.textContent = bestScore;
                    }
                }

                if (player.x < obs.x + obs.w &&
                    player.x + player.w > obs.x &&
                    player.y < obs.y + obs.h &&
                    player.y + player.h > obs.y) {
                    gameOver();
                }

                if (obs.x + obs.w < 0) {
                    obstacles.splice(i, 1);
                }
            });

            particles.forEach((p, i) => {
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2;  // Гравитация для частиц
                p.vx *= 0.98;  // Замедление
                p.rotation += p.rotationSpeed;
                p.life -= 0.015;
                if (p.life <= 0 || p.y > H) particles.splice(i, 1);
            });

            clouds.forEach(c => {
                c.x -= c.speed;
                if (c.x + c.w < 0) {
                    c.x = W;
                    c.y = Math.random() * H * 0.5;
                }
            });
        }

        function drawDino() {
            ctx.save();
            ctx.translate(player.x + player.w / 2, player.y + player.h / 2);
            
            // Энергетический след при беге
            if (player.state === 'run' && frame % 2 === 0) {
                ctx.fillStyle = 'rgba(0, 255, 170, 0.2)';
                ctx.fillRect(-player.w / 2 - 5, -player.h / 2, player.w + 10, player.h);
            }
            
            // Улучшенная тень
            const shadowGrad = ctx.createRadialGradient(0, player.h / 2 + 5, 0, 0, player.h / 2 + 5, player.w);
            shadowGrad.addColorStop(0, 'rgba(0, 0, 0, 0.5)');
            shadowGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = shadowGrad;
            ctx.fillRect(-player.w / 2, player.h / 2 + 3, player.w, 8);
            
            // Свечение персонажа
            ctx.shadowBlur = 25;
            ctx.shadowColor = player.color;
            
            const bodyW = player.w;
            const bodyH = player.state === 'slide' ? player.h : player.h * 0.6;
            const bodyY = player.state === 'slide' ? 0 : -player.h * 0.15;
            
            // Тело с улучшенным градиентом
            const bodyGrad = ctx.createLinearGradient(-bodyW/2, bodyY - bodyH/2, bodyW/2, bodyY + bodyH/2);
            bodyGrad.addColorStop(0, '#00ffaa');
            bodyGrad.addColorStop(0.5, '#00dd99');
            bodyGrad.addColorStop(1, '#00cc88');
            ctx.fillStyle = bodyGrad;
            ctx.fillRect(-bodyW / 2, bodyY - bodyH / 2, bodyW, bodyH);
            
            // Броневые пластины на теле
            ctx.fillStyle = 'rgba(0, 204, 204, 0.3)';
            ctx.fillRect(-bodyW / 2 + 3, bodyY - bodyH / 2 + 3, bodyW - 6, 4);
            ctx.fillRect(-bodyW / 2 + 3, bodyY + bodyH / 2 - 7, bodyW - 6, 4);
            
            if (player.state !== 'slide') {
                // Голова
                const headSize = 22;
                const headY = -player.h / 2 + 3;
                const headGrad = ctx.createLinearGradient(-headSize/2, headY, headSize/2, headY + headSize);
                headGrad.addColorStop(0, '#00ffcc');
                headGrad.addColorStop(1, '#00dd99');
                ctx.fillStyle = headGrad;
                ctx.fillRect(-headSize / 2, headY, headSize, headSize);
                
                // Шлем/антенна
                ctx.fillStyle = '#00ffff';
                ctx.fillRect(-3, headY - 5, 6, 5);
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#00ffff';
                ctx.fillRect(-2, headY - 8, 4, 3);
                
                // Глаза с анимацией
                ctx.shadowBlur = 10;
                const eyeGlow = Math.sin(frame * 0.1) * 0.3 + 0.7;
                ctx.fillStyle = `rgba(0, 255, 255, ${eyeGlow})`;
                ctx.fillRect(-9, headY + 6, 6, 6);
                ctx.fillRect(3, headY + 6, 6, 6);
                
                // Зрачки
                ctx.fillStyle = '#0a0e27';
                ctx.fillRect(-7, headY + 8, 2, 2);
                ctx.fillRect(5, headY + 8, 2, 2);
                
                // Светящийся визор
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 2;
                ctx.shadowBlur = 12;
                ctx.shadowColor = '#00ffff';
                ctx.strokeRect(-headSize / 2 + 2, headY + 3, headSize - 4, 10);
            } else {
                // Режим слайда - только глаза
                ctx.fillStyle = '#00ffff';
                ctx.shadowBlur = 10;
                ctx.fillRect(10, -10, 6, 4);
                ctx.fillRect(10, 2, 6, 4);
            }
            
            // Ноги с улучшенной анимацией
            if (player.state === 'run') {
                const legFrame = Math.floor(player.frame / 4) % 6;
                ctx.shadowBlur = 15;
                
                // Левая нога
                ctx.fillStyle = '#00dd99';
                const leftLegOffset = [0, -2, -3, -2, 0, 2][legFrame];
                ctx.fillRect(-bodyW / 2 + 6, bodyH / 2 + leftLegOffset, 10, 16 - Math.abs(leftLegOffset));
                
                // Правая нога
                const rightLegOffset = [2, 0, -2, -3, -2, 0][legFrame];
                ctx.fillRect(bodyW / 2 - 16, bodyH / 2 + rightLegOffset, 10, 16 - Math.abs(rightLegOffset));
                
                // Ступни с энергией
                ctx.fillStyle = '#00ffaa';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#00ff88';
                ctx.fillRect(-bodyW / 2 + 4, bodyH / 2 + 16, 14, 5);
                ctx.fillRect(bodyW / 2 - 18, bodyH / 2 + 16, 14, 5);
            }
            
            // Энергетическое ядро
            if (player.state !== 'slide') {
                const corePulse = Math.sin(frame * 0.15) * 0.3 + 0.7;
                ctx.fillStyle = `rgba(0, 255, 255, ${corePulse})`;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#00ffff';
                ctx.fillRect(-5, -2, 10, 10);
                
                // Внутреннее ядро
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(-2, 1, 4, 4);
            }
            
            // Энергетический щит при прыжке
            if (player.state === 'jump') {
                ctx.strokeStyle = 'rgba(0, 255, 170, 0.4)';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#00ffaa';
                ctx.strokeRect(-bodyW / 2 - 5, -player.h / 2 - 5, bodyW + 10, player.h + 10);
            }
            
            ctx.restore();
            ctx.shadowBlur = 0;
        }

        function drawObstacles() {
            obstacles.forEach(obs => {
                ctx.save();
                
                if (obs.type === 'low') {
                    // Шипы на земле
                    const obsGrad = ctx.createLinearGradient(obs.x, obs.y, obs.x, obs.y + obs.h);
                    obsGrad.addColorStop(0, '#ff3366');
                    obsGrad.addColorStop(0.5, '#ff1144');
                    obsGrad.addColorStop(1, '#cc0044');
                    ctx.fillStyle = obsGrad;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#ff3366';
                    
                    // Основание
                    ctx.fillRect(obs.x, obs.y + obs.h - 15, obs.w, 15);
                    
                    // Шипы
                    ctx.beginPath();
                    for (let i = 0; i < 3; i++) {
                        const spikeX = obs.x + i * (obs.w / 3) + obs.w / 6;
                        ctx.moveTo(spikeX, obs.y + obs.h - 15);
                        ctx.lineTo(spikeX - 5, obs.y + obs.h - 15);
                        ctx.lineTo(spikeX, obs.y);
                        ctx.lineTo(spikeX + 5, obs.y + obs.h - 15);
                    }
                    ctx.closePath();
                    ctx.fill();
                    
                    // Свечение на шипах
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    for (let i = 0; i < 3; i++) {
                        const spikeX = obs.x + i * (obs.w / 3) + obs.w / 6;
                        ctx.fillRect(spikeX - 1, obs.y + 5, 2, obs.h - 25);
                    }
                    
                    // Опасная полоса
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                    for (let i = 0; i < obs.w; i += 6) {
                        ctx.fillRect(obs.x + i, obs.y + obs.h - 10, 3, 10);
                    }
                    
                } else {
                    // Летающий дрон
                    const hoverOffset = Math.sin((frame + obs.x) * 0.1) * 3;
                    const droneY = obs.y + hoverOffset;
                    
                    const obsGrad = ctx.createRadialGradient(obs.x + obs.w/2, droneY + obs.h/2, 0, obs.x + obs.w/2, droneY + obs.h/2, obs.w);
                    obsGrad.addColorStop(0, '#ffcc00');
                    obsGrad.addColorStop(0.5, '#ffaa00');
                    obsGrad.addColorStop(1, '#ff6600');
                    ctx.fillStyle = obsGrad;
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = '#ffaa00';
                    
                    // Корпус дрона
                    ctx.fillRect(obs.x + 5, droneY + 5, obs.w - 10, obs.h - 10);
                    
                    // Пропеллеры
                    const propAngle = (frame * 0.3) % (Math.PI * 2);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(obs.x + 8, droneY + 5, 6, propAngle, propAngle + Math.PI);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(obs.x + obs.w - 8, droneY + 5, 6, propAngle + Math.PI, propAngle + Math.PI * 2);
                    ctx.stroke();
                    
                    // Глаз дрона
                    ctx.fillStyle = '#ff0000';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ff0000';
                    ctx.fillRect(obs.x + obs.w/2 - 3, droneY + obs.h/2 - 3, 6, 6);
                    
                    // Энергетическое поле
                    ctx.strokeStyle = 'rgba(255, 170, 0, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(obs.x, droneY, obs.w, obs.h);
                }
                
                // Предупреждающая рамка
                const warningPulse = Math.sin(frame * 0.2) * 0.3 + 0.5;
                ctx.strokeStyle = obs.type === 'low' ? `rgba(255, 102, 153, ${warningPulse})` : `rgba(255, 204, 68, ${warningPulse})`;
                ctx.lineWidth = 3;
                ctx.shadowBlur = 10;
                ctx.strokeRect(obs.x - 2, obs.y - 2, obs.w + 4, obs.h + 4);
                
                ctx.restore();
            });
            ctx.shadowBlur = 0;
        }

        function draw() {
            // Улучшенный градиентный фон
            const grad = ctx.createLinearGradient(0, 0, 0, H);
            grad.addColorStop(0, '#0a0e27');
            grad.addColorStop(0.4, '#1a1f3a');
            grad.addColorStop(0.8, '#2a2f4a');
            grad.addColorStop(1, '#1a1f3a');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, W, H);

            // Пульсирующие звезды
            const starSeed = Math.floor(frame / 60);
            for (let i = 0; i < 50; i++) {
                const x = (i * 137.5 + starSeed * 10) % W;
                const y = (i * 73.3) % (H * 0.6);
                const twinkle = Math.sin(frame * 0.05 + i) * 0.5 + 0.5;
                ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + twinkle * 0.4})`;
                ctx.fillRect(x, y, 2, 2);
            }

            // Неоновые огни города (далекие здания)
            for (let i = 0; i < 8; i++) {
                const x = (i * 120 - (frame * 0.3) % 120) % W;
                const buildingH = 40 + (i % 3) * 20;
                ctx.fillStyle = 'rgba(0, 255, 136, 0.05)';
                ctx.fillRect(x, H * 0.5 - buildingH, 80, buildingH);
                ctx.fillStyle = `rgba(0, 255, 136, 0.${2 + (frame + i * 10) % 3})`;
                ctx.fillRect(x + 10, H * 0.5 - buildingH + 5, 10, 10);
            }

            // Облака с параллаксом
            clouds.forEach(c => {
                const cloudGrad = ctx.createRadialGradient(c.x + c.w/2, c.y + c.h/2, 0, c.x + c.w/2, c.y + c.h/2, c.w);
                cloudGrad.addColorStop(0, 'rgba(30, 35, 60, 0.4)');
                cloudGrad.addColorStop(1, 'rgba(30, 35, 60, 0.1)');
                ctx.fillStyle = cloudGrad;
                ctx.fillRect(c.x, c.y, c.w, c.h);
            });

            // Земля с градиентом
            const groundGrad = ctx.createLinearGradient(0, groundY + player.h, 0, H);
            groundGrad.addColorStop(0, '#1a1f3a');
            groundGrad.addColorStop(1, '#0a0e27');
            ctx.fillStyle = groundGrad;
            ctx.fillRect(0, groundY + player.h, W, H - groundY - player.h);
            
            // Основная линия земли с пульсацией
            const linePulse = Math.sin(frame * 0.1) * 0.3 + 0.7;
            ctx.strokeStyle = `rgba(0, 255, 136, ${linePulse})`;
            ctx.lineWidth = 4;
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#00ff88';
            ctx.beginPath();
            ctx.moveTo(0, groundY + player.h);
            ctx.lineTo(W, groundY + player.h);
            ctx.stroke();
            
            // Верхняя линия
            ctx.strokeStyle = 'rgba(0, 204, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#00ccff';
            ctx.beginPath();
            ctx.moveTo(0, groundY + player.h - 2);
            ctx.lineTo(W, groundY + player.h - 2);
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Энергетические вертикальные линии
            ctx.strokeStyle = 'rgba(0, 255, 136, 0.15)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 15; i++) {
                const offset = (frame * speed * 0.8) % 80;
                ctx.beginPath();
                ctx.moveTo(i * 80 - offset, groundY + player.h);
                ctx.lineTo(i * 80 - offset, H);
                ctx.stroke();
            }
            
            // Горизонтальные линии текстуры
            ctx.strokeStyle = 'rgba(0, 255, 136, 0.05)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 5; i++) {
                const y = groundY + player.h + i * 20;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(W, y);
                ctx.stroke();
            }

            // Улучшенные частицы
            particles.forEach(p => {
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(p.rotation);
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life * 0.8;
                ctx.shadowBlur = 10 * p.life;
                ctx.shadowColor = p.color;
                // Разные формы частиц
                if (p.size > 4) {
                    ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
                } else {
                    ctx.beginPath();
                    ctx.arc(0, 0, p.size/2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            });
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;

            drawDino();
            drawObstacles();
        }

        function gameOver() {
            gameState = 'over';
            overlay.classList.remove('hidden');
            menuText.textContent = `Игра окончена! Счёт: ${score}`;
            startBtn.textContent = 'ЗАНОВО';
            instructions.style.display = 'none';
            haptic('heavy');
            addParticles(player.x + player.w / 2, player.y + player.h / 2, '#ff3366', 30);
        }

        function startGame() {
            init();
            gameState = 'play';
            overlay.classList.add('hidden');
            instructions.style.display = 'block';
            startBtn.textContent = 'СТАРТ';
        }

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        startBtn.addEventListener('click', startGame);

        let touchTimer;
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchStartTime = Date.now();
            isTouchHeld = false;
            
            touchTimer = setTimeout(() => {
                isTouchHeld = true;
                if (gameState === 'play') {
                    slide();
                }
            }, 200);
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            clearTimeout(touchTimer);
            
            if (!isTouchHeld && gameState === 'play') {
                jump();
            } else if (gameState !== 'play') {
                startGame();
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && gameState === 'play') {
                e.preventDefault();
                jump();
            } else if (e.code === 'ArrowDown' && gameState === 'play') {
                e.preventDefault();
                slide();
            } else if ((e.code === 'Space' || e.code === 'Enter') && gameState !== 'play') {
                e.preventDefault();
                startGame();
            }
        });

        window.addEventListener('resize', resize);
        resize();
        loop();
    </script>
</body>
</html>
