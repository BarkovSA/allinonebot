<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>Vapor Orbit</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            color-scheme: dark;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: 'Space Grotesk', 'Segoe UI', Tahoma, sans-serif;
            background: #03060b;
            color: #f2fff3;
            overflow: hidden;
            touch-action: none;
        }

        .game-shell {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background:
                radial-gradient(circle at 20% 15%, rgba(111, 255, 164, 0.25), transparent 55%),
                radial-gradient(circle at 85% 0%, rgba(245, 123, 255, 0.25), transparent 45%),
                #04080e;
        }

        canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        .hud {
            position: absolute;
            top: 16px;
            left: 16px;
            right: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 0.2em;
        }

        .score {
            display: flex;
            gap: 20px;
            font-weight: 600;
            font-size: clamp(13px, 1.8vw, 15px);
        }

        .score span {
            font-size: clamp(22px, 4vw, 30px);
            min-width: 90px;
            text-align: right;
            color: #84ff9c;
        }

        .hint {
            opacity: 0.75;
            font-size: clamp(12px, 2vw, 14px);
        }

        .meter {
            position: absolute;
            bottom: 26px;
            left: 50%;
            transform: translateX(-50%);
            width: min(360px, 60vw);
            height: 6px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.15);
            overflow: hidden;
        }

        .meter__fill {
            width: 50%;
            height: 100%;
            background: linear-gradient(90deg, #6fff8c, #ffa928);
            transition: width 120ms linear;
        }

        .overlay {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(3, 6, 11, 0.82);
            backdrop-filter: blur(12px);
            transition: opacity 0.35s ease;
            z-index: 10;
        }

        .overlay--hidden {
            opacity: 0;
            pointer-events: none;
        }

        .overlay__card {
            width: min(380px, 90vw);
            padding: 36px;
            border-radius: 28px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            background: rgba(8, 12, 22, 0.95);
            text-align: center;
            box-shadow: 0 30px 80px rgba(107, 255, 140, 0.22);
        }

        .overlay__card h1 {
            margin: 0 0 12px;
            letter-spacing: 0.3em;
            font-size: 26px;
        }

        .overlay__card p {
            margin: 0 0 24px;
            line-height: 1.6;
            opacity: 0.85;
        }

        button {
            font-family: inherit;
            border: none;
            border-radius: 999px;
            padding: 14px 40px;
            font-size: 15px;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            cursor: pointer;
            background: linear-gradient(120deg, #7effa4, #ff7ad9);
            color: #041106;
            font-weight: 700;
            box-shadow: 0 15px 35px rgba(126, 255, 164, 0.3);
        }

        button:active {
            transform: translateY(1px);
        }

        .touch-zone {
            display: none;
        }

        @media (pointer: coarse) {
            .touch-zone {
                position: absolute;
                top: 0;
                bottom: 0;
                width: 33.334%;
                z-index: 5;
            }

            .touch-zone[data-action="left"] {
                left: 0;
            }

            .touch-zone[data-action="dash"] {
                left: 33.334%;
            }

            .touch-zone[data-action="right"] {
                right: 0;
            }
        }
    </style>
</head>
<body>
    <div class="game-shell">
        <canvas id="orbit" aria-label="Вращайся и не попадайся"></canvas>
        <div class="hud">
            <div class="score">
                <div>BEST <span id="best">00000</span></div>
                <div>FLOW <span id="score">00000</span></div>
            </div>
            <div class="hint" id="hint">Влево/вправо — вращай орбиту · пробел/тап по центру — рывок</div>
        </div>
        <div class="meter">
            <div class="meter__fill" id="chargeFill"></div>
        </div>
        <div class="overlay" id="overlay">
            <div class="overlay__card">
                <h1>VAPOR ORBIT</h1>
                <p id="overlayText">Центрируйся в вихре. Скользи по орбитам. Зарабатывай поток.</p>
                <button id="playBtn">СТАРТ</button>
            </div>
        </div>
        <div class="touch-zone" data-action="left"></div>
        <div class="touch-zone" data-action="dash"></div>
        <div class="touch-zone" data-action="right"></div>
    </div>

    <script>
        const tg = window.Telegram?.WebApp;
        try {
            tg?.ready();
            tg?.expand();
            tg?.enableClosingConfirmation();
        } catch (err) {
            console.warn('Telegram WebApp unavailable', err);
        }

        const canvas = document.getElementById('orbit');
        const ctx = canvas.getContext('2d');
        const overlay = document.getElementById('overlay');
        const overlayText = document.getElementById('overlayText');
        const playBtn = document.getElementById('playBtn');
        const hintEl = document.getElementById('hint');
        const scoreEl = document.getElementById('score');
        const bestEl = document.getElementById('best');
        const chargeFill = document.getElementById('chargeFill');
        const touchZones = document.querySelectorAll('.touch-zone');

        const rand = (min, max) => Math.random() * (max - min) + min;
        const clamp = (value, min, max) => Math.min(max, Math.max(min, value));

        class Spark {
            constructor(x, y, hue) {
                this.x = x;
                this.y = y;
                this.life = rand(0.4, 0.9);
                this.vx = rand(-80, 80);
                this.vy = rand(-80, 80);
                this.size = rand(2, 6);
                this.hue = hue || rand(90, 180);
            }

            update(dt) {
                this.life -= dt;
                this.x += this.vx * dt;
                this.y += this.vy * dt;
            }

            draw(ctx) {
                if (this.life <= 0) return;
                ctx.save();
                ctx.globalAlpha = Math.max(this.life, 0);
                ctx.fillStyle = `hsl(${this.hue}, 80%, 70%)`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class ArcHazard {
            constructor(game) {
                this.game = game;
                this.radius = game.radiusMax + rand(60, 140);
                this.angle = rand(0, Math.PI * 2);
                this.arcWidth = rand(0.3, 0.7);
                this.thickness = rand(10, 26);
                this.speed = rand(140, 250);
                this.color = Math.random() > 0.5 ? '#77ff9c' : '#ff9dd9';
                this.dead = false;
            }

            update(dt) {
                this.radius -= this.speed * dt;
                if (this.radius + this.thickness < this.game.radiusMin - 30) {
                    this.dead = true;
                    this.game.addScore(35);
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.lineCap = 'round';
                ctx.strokeStyle = this.color;
                ctx.lineWidth = this.thickness;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(this.game.cx, this.game.cy, this.radius, this.angle - this.arcWidth / 2, this.angle + this.arcWidth / 2);
                ctx.stroke();
                ctx.restore();
            }
        }

        class VaporGame {
            constructor() {
                this.pixelRatio = window.devicePixelRatio || 1;
                this.controls = { left: false, right: false, dash: false };
                this.state = 'idle';
                this.score = 0;
                this.best = Number(localStorage.getItem('orbitBest') || 0);
                bestEl.textContent = this.best.toString().padStart(5, '0');

                this.sparks = [];
                this.hazards = [];
                this.spawnTimer = 0;
                this.player = {
                    angle: 0,
                    radius: 0,
                    targetRadius: 0,
                    angularVelocity: 0,
                    charge: 1,
                    recoverRate: 0.35
                };

                window.addEventListener('resize', () => this.resize());
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden && this.state === 'playing') {
                        this.pause();
                    }
                });

                document.addEventListener('keydown', (e) => this.handleKey(e, true));
                document.addEventListener('keyup', (e) => this.handleKey(e, false));

                playBtn.addEventListener('click', () => this.start());
                overlay.addEventListener('click', () => this.start());

                touchZones.forEach((zone) => {
                    zone.addEventListener('pointerdown', (e) => {
                        e.preventDefault();
                        this.setControl(zone.dataset.action, true);
                    });
                    zone.addEventListener('pointerup', (e) => {
                        e.preventDefault();
                        this.setControl(zone.dataset.action, false);
                    });
                    zone.addEventListener('pointerleave', () => this.setControl(zone.dataset.action, false));
                    zone.addEventListener('pointercancel', () => this.setControl(zone.dataset.action, false));
                });

                this.resize();
                this.lastTime = performance.now();
                requestAnimationFrame((ts) => this.loop(ts));
            }

            resize() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                canvas.width = this.width * this.pixelRatio;
                canvas.height = this.height * this.pixelRatio;
                canvas.style.width = this.width + 'px';
                canvas.style.height = this.height + 'px';
                ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
                this.cx = this.width / 2;
                this.cy = this.height / 2;
                this.radiusMin = Math.min(this.width, this.height) * 0.16;
                this.radiusMax = Math.min(this.width, this.height) * 0.44;
                this.player.radius = this.radiusMin;
                this.player.targetRadius = this.radiusMin;
            }

            handleKey(e, pressed) {
                if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
                    this.setControl('left', pressed);
                    e.preventDefault();
                } else if (e.code === 'ArrowRight' || e.code === 'KeyD') {
                    this.setControl('right', pressed);
                    e.preventDefault();
                } else if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') {
                    this.setControl('dash', pressed);
                    e.preventDefault();
                }
            }

            setControl(action, pressed) {
                if (!['left', 'right', 'dash'].includes(action)) return;
                this.controls[action] = pressed;
                if (action === 'dash' && pressed) {
                    this.tryDash();
                }
            }

            tryDash() {
                if (this.player.charge <= 0.15 || this.state !== 'playing') return;
                this.player.targetRadius = this.radiusMax;
                this.player.charge = Math.max(0, this.player.charge - 0.4);
                this.addSparks(20, '#ffa6ff');
                this.haptic('medium');
            }

            start() {
                if (this.state === 'playing') return;
                overlay.classList.add('overlay--hidden');
                this.state = 'playing';
                this.score = 0;
                this.hazards = [];
                this.sparks = [];
                this.spawnTimer = 1;
                this.player.angle = 0;
                this.player.angularVelocity = 0;
                this.player.charge = 1;
                this.player.targetRadius = this.radiusMin * 1.05;
                this.lastTime = performance.now();
                overlayText.textContent = 'Сохраняй поток и не дай дугам достать центр.';
                hintEl.textContent = 'Левый/правый — вращай · Пробел/центр — рывок наружу';
            }

            pause() {
                this.state = 'paused';
                overlay.classList.remove('overlay--hidden');
                overlayText.textContent = 'Пауза. Фокусируйся и возвращайся.';
                playBtn.textContent = 'ПРОДОЛЖИТЬ';
            }

            crash() {
                if (this.state !== 'playing') return;
                this.state = 'crashed';
                overlay.classList.remove('overlay--hidden');
                overlayText.textContent = `Поток: ${Math.floor(this.score)} · Лучший: ${this.best}`;
                playBtn.textContent = 'ЕЩЁ ОРБИТУ';
                this.haptic('heavy');
            }

            haptic(type) {
                try {
                    tg?.HapticFeedback?.impactOccurred(type);
                } catch (_) {
                    // ignore
                }
            }

            addScore(amount) {
                this.score += amount;
                if (this.score > this.best) {
                    this.best = Math.floor(this.score);
                    localStorage.setItem('orbitBest', this.best.toString());
                    bestEl.textContent = this.best.toString().padStart(5, '0');
                }
            }

            addSparks(count, hueColor) {
                for (let i = 0; i < count; i++) {
                    this.sparks.push(new Spark(this.cx, this.cy, hueColor ? parseInt(hueColor.replace(/[^0-9]/g, ''), 10) : undefined));
                }
            }

            update(dt) {
                if (this.state !== 'playing') return;

                const accel = 120;
                if (this.controls.left) this.player.angularVelocity -= accel * dt;
                if (this.controls.right) this.player.angularVelocity += accel * dt;
                this.player.angularVelocity *= 0.94;
                this.player.angle += this.player.angularVelocity * dt * 0.01;

                if (!this.controls.dash) {
                    this.player.targetRadius = this.radiusMin * (1.05 + Math.sin(this.player.angle * 6) * 0.02);
                }
                this.player.radius += (this.player.targetRadius - this.player.radius) * dt * 6;

                this.player.charge = clamp(this.player.charge + this.player.recoverRate * dt, 0, 1);
                chargeFill.style.width = `${(this.player.charge * 100).toFixed(1)}%`;

                this.spawnTimer -= dt;
                if (this.spawnTimer <= 0) {
                    this.hazards.push(new ArcHazard(this));
                    this.spawnTimer = rand(0.6, 1.2);
                }

                this.hazards.forEach((hazard) => hazard.update(dt));
                this.hazards = this.hazards.filter((h) => !h.dead);

                this.sparks.forEach((spark) => spark.update(dt));
                this.sparks = this.sparks.filter((s) => s.life > 0);

                this.detectCollisions();
                this.addScore(dt * 12);
                scoreEl.textContent = Math.floor(this.score).toString().padStart(5, '0');
            }

            detectCollisions() {
                for (const hazard of this.hazards) {
                    const radialDiff = Math.abs(this.player.radius - hazard.radius);
                    const angleDiff = Math.abs(Math.atan2(Math.sin(this.player.angle - hazard.angle), Math.cos(this.player.angle - hazard.angle)));
                    if (radialDiff < hazard.thickness / 2 + 6 && angleDiff < hazard.arcWidth / 2) {
                        this.crash();
                        return;
                    }
                    const grazeBand = hazard.thickness / 2 + 18;
                    if (!hazard.grazed && radialDiff < grazeBand && angleDiff < hazard.arcWidth * 0.75) {
                        hazard.grazed = true;
                        this.addScore(12);
                        this.sparks.push(new Spark(
                            this.cx + Math.cos(this.player.angle) * this.player.radius,
                            this.cy + Math.sin(this.player.angle) * this.player.radius,
                            120 + Math.random() * 80
                        ));
                        this.haptic('light');
                    }
                }
            }

            renderBackground() {
                ctx.save();
                ctx.fillStyle = '#03060b';
                ctx.fillRect(0, 0, this.width, this.height);

                const gradient = ctx.createRadialGradient(this.cx, this.cy, this.radiusMin * 0.2, this.cx, this.cy, this.radiusMax * 1.3);
                gradient.addColorStop(0, 'rgba(111,255,164,0.08)');
                gradient.addColorStop(0.5, 'rgba(255,122,217,0.05)');
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, this.width, this.height);

                ctx.globalAlpha = 0.5;
                ctx.strokeStyle = 'rgba(255,255,255,0.05)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 5; i++) {
                    ctx.beginPath();
                    ctx.arc(this.cx, this.cy, this.radiusMin + i * 40, 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.restore();
            }

            renderPlayer() {
                const px = this.cx + Math.cos(this.player.angle) * this.player.radius;
                const py = this.cy + Math.sin(this.player.angle) * this.player.radius;

                ctx.save();
                ctx.shadowBlur = 25;
                ctx.shadowColor = '#7effa4';
                ctx.fillStyle = '#081b13';
                ctx.strokeStyle = '#7effa4';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(px, py, 16, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                ctx.fillStyle = '#ffe57e';
                ctx.beginPath();
                ctx.arc(px + 6, py - 4, 4, 0, Math.PI * 2);
                ctx.arc(px - 6, py - 4, 4, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#ff9dd9';
                ctx.beginPath();
                ctx.arc(px, py, 26, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }

            render() {
                this.renderBackground();
                this.hazards.forEach((hazard) => hazard.draw(ctx));
                this.sparks.forEach((spark) => spark.draw(ctx));
                this.renderPlayer();
            }

            loop(timestamp) {
                const dt = Math.min(0.06, (timestamp - this.lastTime) / 1000);
                this.lastTime = timestamp;
                this.update(dt);
                this.render();
                requestAnimationFrame((ts) => this.loop(ts));
            }
        }

        new VaporGame();
    </script>
</body>
</html>
