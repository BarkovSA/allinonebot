<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>Neon Rex Runner</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            color-scheme: dark;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: 'JetBrains Mono', 'Segoe UI', Tahoma, sans-serif;
            background: #04020b;
            color: #f1f5ff;
            overflow: hidden;
            touch-action: none;
        }

        .game-shell {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: radial-gradient(circle at 20% 20%, rgba(8, 191, 255, 0.2), transparent 45%),
                        radial-gradient(circle at 80% 0%, rgba(255, 69, 178, 0.15), transparent 40%),
                        #020108;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .score {
            display: flex;
            gap: 20px;
            font-weight: 600;
            font-size: clamp(14px, 2vw, 16px);
        }

        .score span {
            font-size: clamp(20px, 4vw, 28px);
            color: #64ffc5;
            display: inline-block;
            min-width: 90px;
            text-align: right;
        }

        .hint {
            opacity: 0.7;
            font-size: clamp(12px, 2vw, 14px);
        }

        .overlay {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(2, 1, 8, 0.85);
            backdrop-filter: blur(10px);
            transition: opacity 0.3s ease;
            z-index: 10;
        }

        .overlay--hidden {
            opacity: 0;
            pointer-events: none;
        }

        .overlay__card {
            width: min(340px, 90vw);
            padding: 32px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 24px;
            background: rgba(0, 6, 21, 0.9);
            box-shadow: 0 20px 80px rgba(2, 214, 255, 0.25);
            text-align: center;
        }

        .overlay__card h1 {
            margin: 0 0 12px;
            font-size: 28px;
            letter-spacing: 0.2em;
        }

        .overlay__card p {
            margin: 0 0 24px;
            opacity: 0.8;
            line-height: 1.4;
        }

        button {
            font-family: inherit;
            border: none;
            border-radius: 999px;
            padding: 12px 36px;
            font-size: 15px;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            cursor: pointer;
            background: linear-gradient(120deg, #0ef3ff, #ff3cbf);
            color: #05030f;
            font-weight: 700;
            box-shadow: 0 12px 30px rgba(14, 243, 255, 0.35);
        }

        button:active {
            transform: translateY(1px);
        }

        .touch-zone {
            display: none;
        }

        @media (pointer: coarse) {
            .touch-zone {
                position: absolute;
                inset: 0;
                display: block;
                z-index: 5;
            }

            .touch-zone[data-action="duck"] {
                right: 50%;
                background: transparent;
            }

            .touch-zone[data-action="jump"] {
                left: 50%;
                background: transparent;
            }
        }
    </style>
</head>
<body>
    <div class="game-shell">
        <canvas id="runner" aria-label="Неоновый раннер"></canvas>
        <div class="hud">
            <div class="score">
                <div>BEST <span id="best">00000</span></div>
                <div>NOW <span id="score">00000</span></div>
            </div>
            <div class="hint" id="hint">Тапни, чтобы прыгнуть · Удерживай слева, чтобы пригнуться</div>
        </div>
        <div class="overlay" id="overlay">
            <div class="overlay__card">
                <h1>NEON REX</h1>
                <p id="overlayText">Без интернета? Без проблем. Пробеги как можно дальше.</p>
                <button id="playBtn">Играть</button>
            </div>
        </div>
        <div class="touch-zone" data-action="duck"></div>
        <div class="touch-zone" data-action="jump"></div>
    </div>

    <script>
        const tg = window.Telegram?.WebApp;
        try {
            tg?.ready();
            tg?.expand();
            tg?.enableClosingConfirmation();
        } catch (err) {
            console.warn('Telegram WebApp unavailable', err);
        }

        const canvas = document.getElementById('runner');
        const ctx = canvas.getContext('2d');
        const overlay = document.getElementById('overlay');
        const overlayText = document.getElementById('overlayText');
        const playBtn = document.getElementById('playBtn');
        const hintEl = document.getElementById('hint');
        const scoreEl = document.getElementById('score');
        const bestEl = document.getElementById('best');
        const touchZones = document.querySelectorAll('.touch-zone');

        const rand = (min, max) => Math.random() * (max - min) + min;

        function roundRectPath(ctx, x, y, w, h, r) {
            const radius = Math.min(r, w / 2, h / 2);
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + w - radius, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
            ctx.lineTo(x + w, y + h - radius);
            ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
            ctx.lineTo(x + radius, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

        class Particle {
            constructor(game, x, y) {
                this.game = game;
                this.x = x;
                this.y = y;
                this.radius = rand(2, 5);
                this.life = rand(0.4, 0.9);
                this.vx = rand(-120, -40);
                this.vy = rand(-40, 20);
                this.color = Math.random() > 0.5 ? '#0ef3ff' : '#ffc857';
            }

            update(dt) {
                this.life -= dt;
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.vy += this.game.gravity * 0.3 * dt;
            }

            draw(ctx) {
                if (this.life <= 0) return;
                ctx.save();
                ctx.globalAlpha = Math.max(this.life, 0);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class Player {
            constructor(game) {
                this.game = game;
                this.width = 90;
                this.height = 88;
                this.duckHeight = 46;
                this.x = 160;
                this.y = 0;
                this.vy = 0;
                this.jumping = false;
                this.ducking = false;
                this.stepTimer = 0;
            }

            onResize() {
                this.ground = this.game.baseLine;
                this.y = this.ground;
                this.x = Math.max(140, this.game.width * 0.18);
            }

            reset() {
                this.vy = 0;
                this.y = this.ground;
                this.jumping = false;
                this.ducking = false;
                this.height = 88;
            }

            jump() {
                if (this.jumping) return;
                this.jumping = true;
                this.vy = -this.game.jumpForce;
                this.game.spawnDust(6);
                this.game.haptic('light');
            }

            endJump() {
                if (this.vy < -400) this.vy = -400;
            }

            setDuck(value) {
                if (this.jumping) return;
                this.ducking = value;
            }

            update(dt) {
                if (this.jumping) {
                    this.vy += this.game.gravity * dt;
                    this.y += this.vy * dt;
                    if (this.y >= this.ground) {
                        this.y = this.ground;
                        this.vy = 0;
                        this.jumping = false;
                        if (this.ducking) this.height = this.duckHeight;
                        this.game.spawnDust(8);
                        this.game.haptic('soft');
                    }
                }

                const targetHeight = this.ducking && !this.jumping ? this.duckHeight : 88;
                this.height += (targetHeight - this.height) * Math.min(1, dt * 18);
                this.stepTimer += dt * (this.game.speed / 280);
            }

            getHitBox() {
                return {
                    x: this.x - 35,
                    y: this.y - this.height,
                    width: 70,
                    height: this.height
                };
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#0ef3ff';
                ctx.lineWidth = 4;
                ctx.strokeStyle = '#ffffff';
                ctx.fillStyle = '#061a2c';

                roundRectPath(ctx, -40, -this.height, 80, this.height - 10, 18);
                ctx.fill();
                ctx.stroke();

                ctx.fillStyle = '#0ef3ff';
                roundRectPath(ctx, 10, -this.height - 10, 34, 34, 10);
                ctx.fill();
                ctx.stroke();

                ctx.shadowBlur = 12;
                ctx.fillStyle = '#ff3cbf';
                ctx.beginPath();
                ctx.arc(32, -this.height, 6, 0, Math.PI * 2);
                ctx.fill();

                const legOffset = Math.sin(this.stepTimer * Math.PI * 2) * 8;
                ctx.strokeStyle = '#0ef3ff';
                ctx.lineCap = 'round';
                ctx.lineWidth = 8;
                ctx.beginPath();
                ctx.moveTo(-12, -6);
                ctx.lineTo(-18, legOffset);
                ctx.moveTo(12, -6);
                ctx.lineTo(18, -legOffset);
                ctx.stroke();
                ctx.restore();
            }
        }

        class Obstacle {
            constructor(game, type) {
                this.game = game;
                this.type = type;
                this.x = game.width + 120;
                this.offscreen = false;
                if (type === 'ptero') {
                    this.width = 70;
                    this.height = 38;
                    this.altitude = rand(90, 200);
                    this.y = game.baseLine - this.altitude;
                    this.anim = 0;
                } else {
                    this.height = rand(60, 150);
                    this.width = rand(30, 55);
                    this.y = game.baseLine;
                    this.cluster = Math.random() > 0.65 ? Math.floor(rand(2, 4)) : 1;
                }
            }

            recalcHeight() {
                if (this.type === 'ptero') {
                    this.y = this.game.baseLine - this.altitude;
                } else {
                    this.y = this.game.baseLine;
                }
            }

            update(dt) {
                this.x -= this.game.speed * dt;
                if (this.type === 'ptero') {
                    this.anim += dt * 8;
                    this.y += Math.sin(this.anim) * 0.4;
                }
                if (this.x + this.width < -120) {
                    this.offscreen = true;
                }
            }

            getHitBox() {
                if (this.type === 'ptero') {
                    return { x: this.x - this.width / 2, y: this.y - this.height / 2, width: this.width, height: this.height };
                }
                return {
                    x: this.x,
                    y: this.y - this.height,
                    width: this.width * this.cluster,
                    height: this.height
                };
            }

            draw(ctx) {
                ctx.save();
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.type === 'ptero' ? '#ff3cbf' : '#64ffc5';
                ctx.fillStyle = this.type === 'ptero' ? '#ff3cbf' : '#64ffc5';

                if (this.type === 'ptero') {
                    ctx.translate(this.x, this.y);
                    const wing = Math.sin(this.anim) * 12;
                    ctx.beginPath();
                    ctx.moveTo(-30, 0);
                    ctx.quadraticCurveTo(0, -wing, 30, 0);
                    ctx.quadraticCurveTo(0, wing, -30, 0);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 14, 10, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    for (let i = 0; i < this.cluster; i++) {
                        const height = this.height * rand(0.85, 1.1);
                        const width = this.width * rand(0.8, 1.2);
                        const x = this.x + i * (this.width + 10);
                        roundRectPath(ctx, x, this.y - height, width, height, 8);
                        ctx.fill();
                    }
                }
                ctx.restore();
            }
        }

        class NeonRunner {
            constructor() {
                this.pixelRatio = window.devicePixelRatio || 1;
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.baseLine = this.height - 140;
                this.speed = 360;
                this.maxSpeed = 900;
                this.jumpForce = 1250;
                this.gravity = 3200;
                this.obstacles = [];
                this.particles = [];
                this.clouds = [];
                this.dayTimer = 0;
                this.spawnTimer = 0;
                this.score = 0;
                this.best = Number(localStorage.getItem('neonRexBest') || 0);
                this.state = 'idle';
                this.player = new Player(this);
                this.lastTime = performance.now();
                this.inputs = { jump: false, duck: false };
                this.initClouds();
                this.resize();
                this.bindEvents();
                requestAnimationFrame((ts) => this.loop(ts));
                bestEl.textContent = this.best.toString().padStart(5, '0');
            }

            initClouds() {
                this.clouds = Array.from({ length: 6 }, () => ({
                    x: rand(0, this.width),
                    y: rand(40, this.height * 0.4),
                    scale: rand(0.4, 1.2),
                    speed: rand(20, 80)
                }));
            }

            bindEvents() {
                window.addEventListener('resize', () => this.resize());
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden && this.state === 'running') {
                        this.pause();
                    } else if (!document.hidden && this.state === 'paused') {
                        this.resume();
                    }
                });

                const keyMap = {
                    Space: 'jump',
                    ArrowUp: 'jump',
                    KeyW: 'jump',
                    ArrowDown: 'duck',
                    KeyS: 'duck'
                };

                document.addEventListener('keydown', (e) => {
                    const action = keyMap[e.code];
                    if (!action) return;
                    e.preventDefault();
                    this.handleInput(action, true);
                });

                document.addEventListener('keyup', (e) => {
                    const action = keyMap[e.code];
                    if (!action) return;
                    e.preventDefault();
                    this.handleInput(action, false);
                });

                playBtn.addEventListener('click', () => this.start());
                overlay.addEventListener('click', () => this.start());

                touchZones.forEach((zone) => {
                    zone.addEventListener('pointerdown', (e) => {
                        e.preventDefault();
                        this.handleInput(zone.dataset.action, true);
                    });
                    zone.addEventListener('pointerup', (e) => {
                        e.preventDefault();
                        this.handleInput(zone.dataset.action, false);
                    });
                    zone.addEventListener('pointerleave', () => this.handleInput(zone.dataset.action, false));
                    zone.addEventListener('pointercancel', () => this.handleInput(zone.dataset.action, false));
                });

                canvas.addEventListener('pointerdown', (e) => {
                    if (e.pointerType === 'mouse') {
                        this.handleInput('jump', true);
                    }
                });
                canvas.addEventListener('pointerup', (e) => {
                    if (e.pointerType === 'mouse') {
                        this.handleInput('jump', false);
                    }
                });
            }

            resize() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.baseLine = this.height - 140;
                canvas.width = this.width * this.pixelRatio;
                canvas.height = this.height * this.pixelRatio;
                canvas.style.width = this.width + 'px';
                canvas.style.height = this.height + 'px';
                ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
                this.player.onResize();
                this.obstacles.forEach((o) => o.recalcHeight());
            }

            handleInput(action, pressed) {
                if (action === 'jump') {
                    if (pressed) {
                        if (this.state === 'idle') {
                            this.start();
                            return;
                        }
                        if (this.state !== 'running') return;
                        this.player.jump();
                    } else {
                        this.player.endJump();
                    }
                } else if (action === 'duck') {
                    this.player.setDuck(pressed);
                }
            }

            haptic(type) {
                try {
                    tg?.HapticFeedback?.impactOccurred(type === 'soft' ? 'soft' : type);
                } catch (_) {
                    // ignore
                }
            }

            spawnDust(count = 4) {
                if (this.state !== 'running') return;
                for (let i = 0; i < count; i++) {
                    this.particles.push(new Particle(this, this.player.x, this.player.y - 8));
                }
            }

            spawnObstacle() {
                const allowFlyers = this.score > 150;
                const type = allowFlyers && Math.random() < 0.35 ? 'ptero' : 'cactus';
                this.obstacles.push(new Obstacle(this, type));
                const spacingBase = type === 'ptero' ? 1.4 : 1;
                this.spawnTimer = (spacingBase + rand(0.4, 1.2)) * (360 / this.speed);
            }

            start() {
                if (this.state === 'running') return;
                overlay.classList.add('overlay--hidden');
                overlayText.textContent = 'Собери больше очков, чем когда-либо';
                this.state = 'running';
                this.speed = 360;
                this.score = 0;
                this.obstacles = [];
                this.particles = [];
                this.spawnTimer = 1.2;
                this.player.reset();
                hintEl.textContent = 'Избегай неоновых препятствий · Набирай очки';
                this.lastTime = performance.now();
                this.haptic('medium');
            }

            crash() {
                if (this.state !== 'running') return;
                this.state = 'crashed';
                this.haptic('heavy');
                overlay.classList.remove('overlay--hidden');
                overlayText.textContent = `Счёт: ${Math.floor(this.score)} · Рекорд: ${this.best}`;
                playBtn.textContent = 'Ещё раз';
            }

            pause() {
                this.state = 'paused';
            }

            resume() {
                if (this.state !== 'paused') return;
                this.state = 'running';
                this.lastTime = performance.now();
            }

            updateScoreDisplay() {
                scoreEl.textContent = Math.floor(this.score).toString().padStart(5, '0');
                if (this.score > this.best) {
                    this.best = Math.floor(this.score);
                    localStorage.setItem('neonRexBest', this.best.toString());
                    bestEl.textContent = this.best.toString().padStart(5, '0');
                }
            }

            loop(timestamp) {
                const dt = Math.min(0.05, (timestamp - this.lastTime) / 1000);
                this.lastTime = timestamp;

                if (this.state === 'running') {
                    this.speed = Math.min(this.maxSpeed, this.speed + dt * 40);
                    this.dayTimer += dt * 0.15;
                    this.spawnTimer -= dt;
                    if (this.spawnTimer <= 0) this.spawnObstacle();

                    this.player.update(dt);
                    this.obstacles.forEach((o) => o.update(dt));
                    this.obstacles = this.obstacles.filter((o) => !o.offscreen);
                    this.particles.forEach((p) => p.update(dt));
                    this.particles = this.particles.filter((p) => p.life > 0);

                    this.clouds.forEach((cloud) => {
                        cloud.x -= cloud.speed * dt;
                        if (cloud.x < -200) {
                            cloud.x = this.width + rand(40, 200);
                            cloud.y = rand(40, this.height * 0.4);
                            cloud.scale = rand(0.4, 1.2);
                        }
                    });

                    for (const obstacle of this.obstacles) {
                        if (this.checkCollision(this.player.getHitBox(), obstacle.getHitBox())) {
                            this.crash();
                            break;
                        }
                    }

                    this.score += dt * (this.speed / 10);
                    this.updateScoreDisplay();
                }

                this.render();
                requestAnimationFrame((ts) => this.loop(ts));
            }

            checkCollision(a, b) {
                return a.x < b.x + b.width &&
                    a.x + a.width > b.x &&
                    a.y < b.y + b.height &&
                    a.y + a.height > b.y;
            }

            renderBackground() {
                const gradient = ctx.createLinearGradient(0, 0, 0, this.height);
                const hue = (Math.sin(this.dayTimer) + 1) * 180;
                gradient.addColorStop(0, `hsl(${hue}, 70%, 18%)`);
                gradient.addColorStop(1, '#05030f');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, this.width, this.height);

                ctx.save();
                ctx.globalAlpha = 0.55;
                this.clouds.forEach((cloud) => {
                    ctx.fillStyle = 'rgba(255,255,255,0.15)';
                    ctx.beginPath();
                    ctx.ellipse(cloud.x, cloud.y, 80 * cloud.scale, 28 * cloud.scale, 0, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.restore();
            }

            renderGround() {
                ctx.save();
                ctx.strokeStyle = '#0ef3ff';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#0ef3ff';
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.moveTo(0, this.baseLine + 4);
                ctx.lineTo(this.width, this.baseLine + 4);
                ctx.stroke();

                ctx.fillStyle = 'rgba(100,255,197,0.08)';
                for (let i = 0; i < this.width; i += 26) {
                    ctx.fillRect(i, this.baseLine + 6, 14, rand(2, 6));
                }
                ctx.restore();
            }

            render() {
                this.renderBackground();
                this.obstacles.forEach((o) => o.draw(ctx));
                this.particles.forEach((p) => p.draw(ctx));
                this.player.draw(ctx);
                this.renderGround();
            }
        }

        new NeonRunner();
    </script>
</body>
</html>
