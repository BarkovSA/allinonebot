<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>T-Rex Runner</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #f7f7f7;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            overflow: hidden;
            touch-action: none;
        }

        body.night {
            background: #050510;
            transition: background-color 0.5s ease;
        }

        .game-wrapper {
            position: relative;
            max-width: 600px;
            width: 100%;
        }

        .game-container {
            position: relative;
            background: transparent;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
        }

        .hud {
            position: absolute;
            top: 10px;
            right: 10px;
            font-family: 'Courier New', monospace;
            font-size: 20px;
            color: #535353;
            user-select: none;
            z-index: 10;
            display: flex;
            gap: 30px;
        }

        body.night .hud {
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }

        .score-label {
            color: #7a7a7a;
            font-size: 14px;
            margin-right: 5px;
        }

        body.night .score-label {
            color: #00aaaa;
            text-shadow: 0 0 5px #00aaaa;
        }

        .game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(247, 247, 247, 0.9);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        body.night .game-over-screen {
            background: rgba(5, 5, 16, 0.9);
        }

        .game-over-screen.show {
            opacity: 1;
            pointer-events: all;
        }

        .game-over-text {
            font-family: 'Courier New', monospace;
            font-size: 36px;
            font-weight: bold;
            color: #535353;
            margin-bottom: 20px;
            letter-spacing: 2px;
        }

        body.night .game-over-text {
            color: #ff0055;
            text-shadow: 0 0 10px #ff0055;
        }

        .restart-btn {
            width: 72px;
            height: 64px;
            background: #535353;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            transition: transform 0.1s ease;
        }

        .restart-btn:hover {
            transform: scale(1.1);
        }

        .restart-btn:active {
            transform: scale(0.95);
        }

        .restart-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 0;
            height: 0;
            border-left: 20px solid #f7f7f7;
            border-top: 15px solid transparent;
            border-bottom: 15px solid transparent;
        }

        body.night .restart-btn {
            background: #00ffff;
            box-shadow: 0 0 15px #00ffff;
        }

        body.night .restart-btn::before {
            border-left-color: #050510;
        }

        @media (max-width: 600px) {
            .hud {
                font-size: 16px;
                top: 5px;
                right: 5px;
            }

            .game-over-text {
                font-size: 28px;
            }
        }
    </style>
</head>
<body>
    <div class="game-wrapper">
        <div class="game-container">
            <div class="hud">
                <div><span class="score-label">HI</span><span id="highScore">00000</span></div>
                <div id="score">00000</div>
            </div>
            <canvas id="gameCanvas"></canvas>
            <div class="game-over-screen" id="gameOverScreen">
                <div class="game-over-text">GAME OVER</div>
                <button class="restart-btn" id="restartBtn" aria-label="Restart"></button>
            </div>
        </div>
    </div>

    <script>
        // ==================== TELEGRAM WEBAPP ====================
        const tg = window.Telegram?.WebApp;
        if (tg) {
            tg.ready();
            tg.expand();
            tg.enableClosingConfirmation();
        }

        // ==================== GAME CONFIGURATION ====================
        const CONFIG = {
            WIDTH: 600,
            HEIGHT: 150,
            FPS: 60,
            GRAVITY: 0.6,
            JUMP_VELOCITY: -10,
            MIN_JUMP_HEIGHT: 30,
            SPEED_INITIAL: 4.5,
            SPEED_MAX: 13,
            SPEED_ACCELERATION: 0.001,
            SPEED_DROP_COEFFICIENT: 3,
            GROUND_Y: 105,
            CLEAR_TIME: 3000,
            NIGHT_INTERVAL: 700,
            ACHIEVEMENT_INTERVAL: 100,
            DISTANCE_COEFFICIENT: 0.025
        };

        const COLORS = {
            DAY: {
                BG: '#f7f7f7',
                FG: '#535353',
                GROUND: '#535353'
            },
            NIGHT: {
                BG: '#050510',
                FG: '#00ffff',
                GROUND: '#00ffff'
            }
        };

        // ==================== CANVAS SETUP ====================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;

        function resizeCanvas() {
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            const scale = Math.min(rect.width / CONFIG.WIDTH, 1);
            
            canvas.width = CONFIG.WIDTH * dpr;
            canvas.height = CONFIG.HEIGHT * dpr;
            canvas.style.width = CONFIG.WIDTH * scale + 'px';
            canvas.style.height = CONFIG.HEIGHT * scale + 'px';
            
            ctx.scale(dpr, dpr);
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ==================== SPRITE GENERATOR ====================
        class SpriteGenerator {
            static drawBitmap(ctx, bitmap, scale = 2, offsetX = 0, offsetY = 0) {
                for (let y = 0; y < bitmap.length; y++) {
                    const row = bitmap[y];
                    for (let x = 0; x < row.length; x++) {
                        if (row[x] !== ' ') {
                            ctx.fillRect((x * scale) + offsetX, (y * scale) + offsetY, scale, scale);
                        }
                    }
                }
            }

            static createNeonVariant(sourceCanvas, color) {
                const canvas = document.createElement('canvas');
                canvas.width = sourceCanvas.width;
                canvas.height = sourceCanvas.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(sourceCanvas, 0, 0);
                ctx.globalCompositeOperation = 'source-in';
                ctx.fillStyle = color;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                return canvas;
            }

            static createTRex() {
                const canvas = document.createElement('canvas');
                canvas.width = 88;
                canvas.height = 94;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#535353';
                
                const dinoStand = [
                    "           xxxxxxxx",
                    "           xxxxxxxx",
                    "           xxx xxxx",
                    "           xxxxxxxx",
                    "           xxxxxxxx",
                    "           xxxxxxxx",
                    "   xx      xxxxxx  ",
                    "   xx      xxxxx   ",
                    "   xxx     xxxxx   ",
                    "   xxxx    xxxxx   ",
                    "   xxxxx   xxxxx   ",
                    "   xxxxxx  xxxxx   ",
                    "   xxxxxxxxxxxxx   ",
                    "   xxxxxxxxxxxxx   ",
                    "    xxxxxxxxxxx    ",
                    "      xxxxxxxxx    ",
                    "      xx     xx    ",
                    "      xx     xx    ",
                    "      xx     xx    ",
                    "      xx     xx    ",
                    "      xx     xx    "
                ];

                const dinoRun1 = [
                    "           xxxxxxxx",
                    "           xxxxxxxx",
                    "           xxx xxxx",
                    "           xxxxxxxx",
                    "           xxxxxxxx",
                    "           xxxxxxxx",
                    "   xx      xxxxxx  ",
                    "   xx      xxxxx   ",
                    "   xxx     xxxxx   ",
                    "   xxxx    xxxxx   ",
                    "   xxxxx   xxxxx   ",
                    "   xxxxxx  xxxxx   ",
                    "   xxxxxxxxxxxxx   ",
                    "   xxxxxxxxxxxxx   ",
                    "    xxxxxxxxxxx    ",
                    "      xxxxxxxxx    ",
                    "      xx     x     ",
                    "      xx     x     ",
                    "      xx           ",
                    "      xx           ",
                    "      xx           "
                ];

                const dinoRun2 = [
                    "           xxxxxxxx",
                    "           xxxxxxxx",
                    "           xxx xxxx",
                    "           xxxxxxxx",
                    "           xxxxxxxx",
                    "           xxxxxxxx",
                    "   xx      xxxxxx  ",
                    "   xx      xxxxx   ",
                    "   xxx     xxxxx   ",
                    "   xxxx    xxxxx   ",
                    "   xxxxx   xxxxx   ",
                    "   xxxxxx  xxxxx   ",
                    "   xxxxxxxxxxxxx   ",
                    "   xxxxxxxxxxxxx   ",
                    "    xxxxxxxxxxx    ",
                    "      xxxxxxxxx    ",
                    "      x      xx    ",
                    "      x      xx    ",
                    "             xx    ",
                    "             xx    ",
                    "             xx    "
                ];

                const dinoDuck = [
                    "                      xxxxxxxx",
                    "                      xxxxxxxx",
                    "                      xxx xxxx",
                    "                      xxxxxxxx",
                    "                      xxxxxxxx",
                    "                      xxxxxxxx",
                    "  xxxxxx      xxxxxx  ",
                    "  xxxxxx      xxxxx   ",
                    "  xxxxxxx     xxxxx   ",
                    "  xxxxxxxx    xxxxx   ",
                    "  xxxxxxxxx   xxxxx   ",
                    "  xxxxxxxxxx  xxxxx   ",
                    "  xxxxxxxxxxxxxxxxx   ",
                    "  xxxxxxxxxxxxxxxxx   ",
                    "   xxxxxxxxxxxxxxx    ",
                    "     xxxxxxxxxxxxx    ",
                    "     xx        xx     ",
                    "     xx        xx     "
                ];

                // Frame 1 (Run1)
                this.drawBitmap(ctx, dinoRun1, 2, 0, 0);
                
                // Frame 2 (Run2) - offset 44px
                this.drawBitmap(ctx, dinoRun2, 2, 44, 0);
                
                // Jumping - offset y=47 (using Stand)
                this.drawBitmap(ctx, dinoStand, 2, 0, 47);
                
                // Ducking - offset x=88
                this.drawBitmap(ctx, dinoDuck, 2, 88, 0);
                
                return canvas;
            }

            static createCactus(type = 'small') {
                const canvas = document.createElement('canvas');
                const w = type === 'small' ? 17 : 25;
                const h = type === 'small' ? 35 : 50;
                canvas.width = w * 3;
                canvas.height = h;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#535353';
                
                const cactusSmall = [
                    "      xx      ",
                    "      xx      ",
                    "   x  xx      ",
                    "   x  xx      ",
                    "   x  xx      ",
                    "   x  xx      ",
                    "   x  xx   x  ",
                    "   x  xx   x  ",
                    "   xxxxxxxxx  ",
                    "      xx      ",
                    "      xx      ",
                    "      xx      ",
                    "      xx      ",
                    "      xx      ",
                    "      xx      ",
                    "      xx      "
                ];
                
                const cactusLarge = [
                    "       xx       ",
                    "       xx       ",
                    "   xx  xx       ",
                    "   xx  xx       ",
                    "   xx  xx       ",
                    "   xx  xx       ",
                    "   xx  xx   xx  ",
                    "   xx  xx   xx  ",
                    "   xxxxxxxxxxx  ",
                    "       xx       ",
                    "       xx       ",
                    "       xx       ",
                    "       xx       ",
                    "       xx       ",
                    "       xx       "
                ];

                const bitmap = type === 'small' ? cactusSmall : cactusLarge;
                const scale = type === 'small' ? 2 : 3;

                for (let i = 0; i < 3; i++) {
                    this.drawBitmap(ctx, bitmap, scale, i * w, 0);
                }
                
                return canvas;
            }

            static createPterodactyl() {
                const canvas = document.createElement('canvas');
                canvas.width = 92;
                canvas.height = 80;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#535353';
                
                const ptero1 = [
                    "      xx        ",
                    "     xxxx       ",
                    "    xxxxxx      ",
                    "   xxx  xxx     ",
                    "  xxx    xxx    ",
                    " xxx      xxx   ",
                    "xxx        xxx  ",
                    "xxxxxxxxxxxxxxx ",
                    " xxxxxxxxxxxxx  ",
                    "  xxxxxxxxxxx   ",
                    "   xxxxxxxxx    "
                ];

                const ptero2 = [
                    "   xxxxxxxxx    ",
                    "  xxxxxxxxxxx   ",
                    " xxxxxxxxxxxxx  ",
                    "xxxxxxxxxxxxxxx ",
                    "xxx        xxx  ",
                    " xxx      xxx   ",
                    "  xxx    xxx    ",
                    "   xxx  xxx     ",
                    "    xxxxxx      ",
                    "     xxxx       ",
                    "      xx        "
                ];
                
                // Simplified Ptero
                const pteroSimple1 = [
                    "             xx ",
                    "            xx  ",
                    "           xx   ",
                    "          xx    ",
                    "         xx     ",
                    "        xx      ",
                    "       xx       ",
                    "      xx        ",
                    "     xx         ",
                    "    xx          ",
                    "   xx           ",
                    "  xxxxxxxxxxxxx ",
                    "   xxxxxxxxxxx  ",
                    "    xxxxxxxxx   ",
                    "     xxxxxxx    "
                ];

                const pteroSimple2 = [
                    "  xxxxxxxxxxxxx ",
                    "   xxxxxxxxxxx  ",
                    "    xxxxxxxxx   ",
                    "     xxxxxxx    ",
                    "      xx        ",
                    "       xx       ",
                    "        xx      ",
                    "         xx     ",
                    "          xx    ",
                    "           xx   ",
                    "            xx  ",
                    "             xx "
                ];

                this.drawBitmap(ctx, pteroSimple1, 2, 0, 10);
                this.drawBitmap(ctx, pteroSimple2, 2, 46, 10);
                
                return canvas;
            }

            static createCloud() {
                const canvas = document.createElement('canvas');
                canvas.width = 46;
                canvas.height = 14;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#535353';
                
                const cloud = [
                    "   xxxxxx   ",
                    " xxxxxxxxxx ",
                    "xxxxxxxxxxxx",
                    "xxxxxxxxxxxx",
                    " xxxxxxxxxx ",
                    "   xxxxxx   "
                ];
                
                this.drawBitmap(ctx, cloud, 2, 0, 0);
                
                return canvas;
            }

            static createGround() {
                const canvas = document.createElement('canvas');
                canvas.width = 1200;
                canvas.height = 24;
                const ctx = canvas.getContext('2d');
                
                ctx.fillStyle = '#535353';
                // Ground line with bumps
                for (let x = 0; x < 1200; x += 4) {
                    const h = Math.random() > 0.5 ? 2 : 3;
                    ctx.fillRect(x, 0, 2, h);
                }
                
                return canvas;
            }
        }

        // ==================== GAME ENTITIES ====================
        class TRex {
            constructor() {
                this.sprite = SpriteGenerator.createTRex();
                this.spriteNight = SpriteGenerator.createNeonVariant(this.sprite, COLORS.NIGHT.FG);
                this.x = 50;
                this.y = CONFIG.GROUND_Y;
                this.width = 44;
                this.height = 42;
                this.velocityY = 0;
                this.jumping = false;
                this.ducking = false;
                this.frame = 0;
                this.frameTimer = 0;
                this.frameDelay = 100;
            }

            jump() {
                if (!this.jumping && !this.ducking) {
                    this.velocityY = CONFIG.JUMP_VELOCITY;
                    this.jumping = true;
                    if (tg) tg.HapticFeedback?.impactOccurred('light');
                }
            }

            duck(isDucking) {
                if (!this.jumping) {
                    this.ducking = isDucking;
                    if (isDucking) {
                        this.height = 30;
                    } else {
                        this.height = 47;
                    }
                }
            }

            speedDrop() {
                if (this.jumping) {
                    this.velocityY = 1;
                }
            }

            update(deltaTime) {
                // Gravity
                if (this.jumping) {
                    this.velocityY += CONFIG.GRAVITY;
                    this.y += this.velocityY;

                    if (this.y >= CONFIG.GROUND_Y) {
                        this.y = CONFIG.GROUND_Y;
                        this.jumping = false;
                        this.velocityY = 0;
                    }
                }

                // Animation
                if (!this.jumping) {
                    this.frameTimer += deltaTime;
                    if (this.frameTimer >= this.frameDelay) {
                        this.frame = this.frame === 0 ? 1 : 0;
                        this.frameTimer = 0;
                    }
                }
            }

            draw(nightMode = false) {
                ctx.save();
                
                const sprite = nightMode ? this.spriteNight : this.sprite;
                if (nightMode) {
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = COLORS.NIGHT.FG;
                }

                let sx = this.jumping ? 0 : this.frame * 44;
                let sy = this.jumping ? 47 : 0;
                
                if (this.ducking) {
                    sx = 88;
                    sy = 0;
                    ctx.drawImage(sprite, sx, sy, 59, 30, this.x, this.y + 17, 59, 30);
                } else {
                    ctx.drawImage(sprite, sx, sy, 44, 47, this.x, this.y, 44, 47);
                }
                
                ctx.restore();
            }

            getCollisionBox() {
                return {
                    x: this.x + 4,
                    y: this.y + 4,
                    width: (this.ducking ? 59 : 44) - 8,
                    height: this.height - 8
                };
            }
        }

        class Obstacle {
            constructor(type, speed) {
                this.type = type;
                this.speed = speed;
                
                if (type === 'cactus_small') {
                    this.sprite = SpriteGenerator.createCactus('small');
                    this.width = 17;
                    this.height = 32;
                    this.y = CONFIG.GROUND_Y + 15;
                } else if (type === 'cactus_large') {
                    this.sprite = SpriteGenerator.createCactus('large');
                    this.width = 25;
                    this.height = 45;
                    this.y = CONFIG.GROUND_Y + 2;
                } else if (type === 'pterodactyl') {
                    this.sprite = SpriteGenerator.createPterodactyl();
                    this.width = 46;
                    this.height = 40;
                    const heights = [CONFIG.GROUND_Y - 20, CONFIG.GROUND_Y - 50, CONFIG.GROUND_Y - 80];
                    this.y = heights[Math.floor(Math.random() * heights.length)];
                    this.frame = 0;
                    this.frameTimer = 0;
                }
                
                this.spriteNight = SpriteGenerator.createNeonVariant(this.sprite, COLORS.NIGHT.FG);
                
                this.x = CONFIG.WIDTH;
                this.size = Math.floor(Math.random() * 2) + 1;
                this.remove = false;
            }

            update(deltaTime) {
                this.x -= this.speed;
                
                if (this.type === 'pterodactyl') {
                    this.frameTimer += deltaTime;
                    if (this.frameTimer >= 100) {
                        this.frame = this.frame === 0 ? 1 : 0;
                        this.frameTimer = 0;
                    }
                }
                
                if (this.x + this.width * this.size < 0) {
                    this.remove = true;
                }
            }

            draw(nightMode = false) {
                ctx.save();
                
                const sprite = nightMode ? this.spriteNight : this.sprite;
                if (nightMode) {
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = COLORS.NIGHT.FG;
                }
                
                if (this.type === 'pterodactyl') {
                    const sx = this.frame * 46;
                    ctx.drawImage(sprite, sx, 0, 46, 40, this.x, this.y, 46, 40);
                } else {
                    for (let i = 0; i < this.size; i++) {
                        ctx.drawImage(sprite, i * this.width, 0, this.width, this.height, 
                                    this.x + i * this.width, this.y, this.width, this.height);
                    }
                }
                
                ctx.restore();
            }

            getCollisionBox() {
                return {
                    x: this.x + 4,
                    y: this.y + 4,
                    width: this.width * this.size - 8,
                    height: this.height - 8
                };
            }
        }

        class Cloud {
            constructor() {
                this.sprite = SpriteGenerator.createCloud();
                this.spriteNight = SpriteGenerator.createNeonVariant(this.sprite, '#333344'); // Dimmer cloud for night
                this.x = CONFIG.WIDTH + Math.random() * 200;
                this.y = Math.random() * 50 + 20;
                this.width = 46;
                this.height = 14;
                this.speed = 0.5;
            }

            update() {
                this.x -= this.speed;
                if (this.x + this.width < 0) {
                    this.x = CONFIG.WIDTH + Math.random() * 200;
                    this.y = Math.random() * 50 + 20;
                }
            }

            draw(nightMode = false) {
                ctx.save();
                const sprite = nightMode ? this.spriteNight : this.sprite;
                ctx.drawImage(sprite, this.x, this.y, this.width, this.height);
                ctx.restore();
            }
        }

        class Ground {
            constructor() {
                this.sprite = SpriteGenerator.createGround();
                this.spriteNight = SpriteGenerator.createNeonVariant(this.sprite, COLORS.NIGHT.GROUND);
                this.x1 = 0;
                this.x2 = 1200;
                this.y = CONFIG.GROUND_Y + 54;
                this.height = 24;
            }

            update(speed) {
                this.x1 -= speed;
                this.x2 -= speed;

                if (this.x1 <= -1200) {
                    this.x1 = this.x2 + 1200;
                }
                if (this.x2 <= -1200) {
                    this.x2 = this.x1 + 1200;
                }
            }

            draw(nightMode = false) {
                ctx.save();
                const sprite = nightMode ? this.spriteNight : this.sprite;
                if (nightMode) {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = COLORS.NIGHT.GROUND;
                }
                ctx.drawImage(sprite, this.x1, this.y, 1200, this.height);
                ctx.drawImage(sprite, this.x2, this.y, 1200, this.height);
                ctx.restore();
            }
        }

        // ==================== GAME MANAGER ====================
        class Game {
            constructor() {
                this.tRex = new TRex();
                this.ground = new Ground();
                this.obstacles = [];
                this.clouds = [];
                this.score = 0;
                this.highScore = parseInt(localStorage.getItem('trexHighScore') || '0');
                this.distance = 0;
                this.speed = CONFIG.SPEED_INITIAL;
                this.running = false;
                this.gameOver = false;
                this.nightMode = false;
                this.lastTime = 0;
                this.obstacleTimer = 0;
                this.obstacleInterval = 1500;
                this.clearTime = 0;
                this.nightTimer = 0;
                this.achievementFlash = 0;

                // Create initial clouds
                for (let i = 0; i < 5; i++) {
                    const cloud = new Cloud();
                    cloud.x = Math.random() * CONFIG.WIDTH;
                    this.clouds.push(cloud);
                }

                this.updateScoreDisplay();
                this.setupControls();
                this.loop(0);
            }

            setupControls() {
                // Keyboard
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' || e.code === 'ArrowUp') {
                        e.preventDefault();
                        if (this.gameOver) {
                            this.restart();
                        } else if (!this.running) {
                            this.start();
                        } else {
                            this.tRex.jump();
                        }
                    } else if (e.code === 'ArrowDown') {
                        e.preventDefault();
                        if (this.running && !this.gameOver) {
                            this.tRex.duck(true);
                            this.tRex.speedDrop();
                        }
                    }
                });

                document.addEventListener('keyup', (e) => {
                    if (e.code === 'ArrowDown') {
                        e.preventDefault();
                        this.tRex.duck(false);
                    }
                });

                // Touch/Mouse
                const handleStart = (e) => {
                    e.preventDefault();
                    if (this.gameOver) {
                        this.restart();
                    } else if (!this.running) {
                        this.start();
                    } else {
                        this.tRex.jump();
                    }
                };

                canvas.addEventListener('touchstart', handleStart);
                canvas.addEventListener('mousedown', handleStart);

                // Restart button
                document.getElementById('restartBtn').addEventListener('click', () => {
                    this.restart();
                });
            }

            start() {
                this.running = true;
                if (tg) tg.HapticFeedback?.impactOccurred('medium');
            }

            restart() {
                this.tRex = new TRex();
                this.obstacles = [];
                this.score = 0;
                this.distance = 0;
                this.speed = CONFIG.SPEED_INITIAL;
                this.running = true;
                this.gameOver = false;
                this.obstacleTimer = 0;
                this.clearTime = 0;
                this.nightTimer = 0;
                this.nightMode = false;
                document.body.classList.remove('night');
                document.getElementById('gameOverScreen').classList.remove('show');
                this.updateScoreDisplay();
                if (tg) tg.HapticFeedback?.impactOccurred('medium');
            }

            checkCollision(box1, box2) {
                return box1.x < box2.x + box2.width &&
                       box1.x + box1.width > box2.x &&
                       box1.y < box2.y + box2.height &&
                       box1.y + box1.height > box2.y;
            }

            updateScoreDisplay() {
                document.getElementById('score').textContent = String(this.score).padStart(5, '0');
                document.getElementById('highScore').textContent = String(this.highScore).padStart(5, '0');
            }

            handleGameOver() {
                this.running = false;
                this.gameOver = true;

                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('trexHighScore', this.highScore);
                    this.updateScoreDisplay();
                    if (tg) tg.HapticFeedback?.notificationOccurred('success');
                } else {
                    if (tg) tg.HapticFeedback?.notificationOccurred('error');
                }

                document.getElementById('gameOverScreen').classList.add('show');
            }

            spawnObstacle() {
                const types = ['cactus_small', 'cactus_large'];
                if (this.speed > 8) {
                    types.push('pterodactyl');
                }
                
                const type = types[Math.floor(Math.random() * types.length)];
                const obstacle = new Obstacle(type, this.speed);
                this.obstacles.push(obstacle);
            }

            update(deltaTime) {
                if (!this.running || this.gameOver) return;

                this.clearTime += deltaTime;

                // Update distance and score
                this.distance += this.speed * deltaTime / 16.67;
                const newScore = Math.floor(this.distance * CONFIG.DISTANCE_COEFFICIENT);
                
                // Achievement flash
                if (newScore > this.score && newScore % CONFIG.ACHIEVEMENT_INTERVAL === 0) {
                    this.achievementFlash = 200;
                    if (tg) tg.HapticFeedback?.notificationOccurred('success');
                }
                
                this.score = newScore;
                this.updateScoreDisplay();

                // Speed increase
                if (this.speed < CONFIG.SPEED_MAX) {
                    this.speed += CONFIG.SPEED_ACCELERATION * deltaTime;
                }

                // Night mode toggle
                this.nightTimer += this.speed * deltaTime / 16.67;
                if (this.nightTimer >= CONFIG.NIGHT_INTERVAL * 100) {
                    this.nightMode = !this.nightMode;
                    document.body.classList.toggle('night', this.nightMode);
                    this.nightTimer = 0;
                }

                // Update entities
                this.tRex.update(deltaTime);
                this.ground.update(this.speed);

                // Clouds
                this.clouds.forEach(cloud => cloud.update());

                // Obstacles
                if (this.clearTime > CONFIG.CLEAR_TIME) {
                    this.obstacleTimer += deltaTime;
                    if (this.obstacleTimer >= this.obstacleInterval) {
                        this.spawnObstacle();
                        this.obstacleTimer = 0;
                        this.obstacleInterval = 1000 + Math.random() * 1000;
                    }
                }

                this.obstacles.forEach(obstacle => {
                    obstacle.update(deltaTime);
                    
                    // Collision detection
                    const tRexBox = this.tRex.getCollisionBox();
                    const obstacleBox = obstacle.getCollisionBox();
                    
                    if (this.checkCollision(tRexBox, obstacleBox)) {
                        this.handleGameOver();
                    }
                });

                // Remove off-screen obstacles
                this.obstacles = this.obstacles.filter(o => !o.remove);

                // Achievement flash
                if (this.achievementFlash > 0) {
                    this.achievementFlash -= deltaTime;
                }
            }

            draw() {
                // Clear canvas
                ctx.fillStyle = this.nightMode ? COLORS.NIGHT.BG : COLORS.DAY.BG;
                ctx.fillRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

                // Draw entities
                this.clouds.forEach(cloud => cloud.draw(this.nightMode));
                this.ground.draw(this.nightMode);
                
                // Achievement flash (hide score briefly)
                if (this.achievementFlash <= 0 || Math.floor(this.achievementFlash / 50) % 2 === 0) {
                    this.obstacles.forEach(obstacle => obstacle.draw(this.nightMode));
                }
                
                this.tRex.draw(this.nightMode);
            }

            loop(timestamp) {
                const deltaTime = timestamp - this.lastTime;
                this.lastTime = timestamp;

                this.update(deltaTime);
                this.draw();

                requestAnimationFrame((t) => this.loop(t));
            }
        }

        // ==================== START GAME ====================
        const game = new Game();
    </script>
</body>
</html>
